# 操作系统

## 计算机系统概述

### OS的概念和功能

![image-20220225203238084](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225203238084.png)

#### OS的概念和定义

> 什么是操作系统？

- ==操作系统是系统资源的管理者

![image-20220225204141696](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225204141696.png)

- 向上层提供方便易用的服务
- 是最接近硬件的一层软件

![image-20220225203830273](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225203830273.png)



#### OS的功能和目标

王道书上的(p4)

``操作系统作为计算机系统资源的管理者``

处理机管理

存储器管理

文件管理

设备管理

``作为用户与计算机硬件系统之间的接口``



``操作系统用作扩充机器``

> 操作系统要做些什么？

##### 向上层提供方便易用的服务

![image-20220225204341496](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225204341496.png)

![image-20220225204639900](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225204639900.png)

![image-20220225204752003](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225204752003.png)

![image-20220225205159339](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225205159339.png)



##### 作为最接近硬件的层次

![image-20220225205717009](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225205717009.png)

##### 总结

![image-20220225205330913](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225205330913.png)

![image-20220225205746419](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225205746419.png)

#### OS的特征

![image-20220225205849806](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225205849806.png)

##### 并发

###### 并发和并行

![image-20220225210035833](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225210035833.png)

例如四核的CPU，只能同时运行四个软件，如果想运行第五个，那只能第四个和第五个交替的运行，交替使用CPU

![image-20220225210245349](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225210245349.png)

##### 共享

![image-20220225213039511](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225213039511.png)

![image-20220225213201398](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225213201398.png)

##### 虚拟

###### 空分复用技术

![image-20220225213521005](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225213521005.png)

###### 时分复用技术

![image-20220225213709992](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225213709992.png)





##### 异步

![image-20220225214331053](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225214331053.png)

![image-20220602110934283](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220602110934283.png)

##### 总结

![image-20220225214414911](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220225214414911.png)

### OS的发展和分类

![image-20220226153645439](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226153645439.png)

#### 手工操作阶段

> 用户独占全机，人机速度矛盾导致资源利用率极低

![image-20220226163737197](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226163737197.png)

#### 单道批处理系统

> 优点：引入脱机输入\输出技术，缓解了一定程度的人机速度矛盾，资源利用率有所提升
>
> 缺点：内存中只能有一道程序运行，CPU大部分时间是再空闲等待IO



![image-20220226163916098](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226163916098.png)

![image-20220226164012117](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226164012117.png)

![image-20220226165526992](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226165526992.png)

#### 多道批处理系统

![image-20220226165942637](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226165942637.png)

#### 分时操作系统

![image-20220226170140012](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226170140012.png)

#### 实时操作系统

![image-20220226170306729](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226170306729.png)

#### 其他操作系统

![image-20220226170335666](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226170335666.png)

![image-20220226170355125](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226170355125.png)

### OS运行环境

#### 操作系统的运行机制

计算机系统中，通常CPU执行两种不同性质的程序，一种是操作系统内核程序，一种是用户自编程序（应用程序）。

对操作系统而言，这两种程序的作用不同，前者是后者的管理者，因此管理程序（即内核程序）要执行一些特权指令，而被管理者（应用程序）出于安全考虑不能执行这些指令。

具体实现上：CPU状态分为用户态（目态）和核心态（管态，内核态）。

在软件工程思想和结构化程序设计方法影响下诞生的现代操作系统，几乎都说层次的结构。操作系统功能分别被设置在不同的层次上。

一些与硬件紧密关联的模块：如时钟管理、中断处理、设备驱动处于最底层。

其次是运行频率比较高的程序，如进程管理，存储器管理，和设备管理等。这两部分构成了``操作系统内核``。



##### 内核程序和应用程序

![image-20220226185417775](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220226185417775.png)

##### 特权指令和非特权指令

![image-20220315171503161](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315171503161.png)

##### 内核态和用户态

![image-20220315171654369](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315171654369.png)

##### 内核态和用户态的切换

> CPU中有个寄存器叫做程序状态字寄存器PSW,有两个二进制位，1表示内核态，0表示用户态

![image-20220315171849635](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315171849635.png)

![image-20220315190112525](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315190112525.png)

![image-20220315190220979](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315190220979.png)

#### 中断和异常

##### 中断的作用

> 让操作系统内核强行夺回CPU控制权，让CPU从用户态转变为内核态。
>
> 如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。就没有并发了。

![image-20220315204746668](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315204746668.png)

##### 中断的类型

陷入：有可能应用程序需要请求操作系统内核的服务

![image-20220315205631933](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205631933.png)

###### 内中断（异常、意外）

> 与当前执行的指令有关，中断信号来源于CPU内部
>
> 例1--也许是终止吧...
>
> 例2--终止
>
> 例3--陷入

![image-20220315205017225](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205017225.png)

![image-20220315205110498](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205110498.png)

###### 外中断（中断）

> 与当前执行的指令无关，中断信号来源于CPU外部

![image-20220315205225469](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205225469.png)

![image-20220315205350828](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205350828.png)

![image-20220315205453063](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205453063.png)



###### 基本原理

![image-20220315205751195](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315205751195.png)

#### 系统调用

##### 什么是系统调用？

系统调用：应用程序可以通过系统调用来请求获得操作系统内核的服务

``联机命令接口``：

又叫做交互式命令接口,适用于分时操作系统或者实时操作系统，由一组键盘操作命令组成。用户通过控制台输入命令。

``脱机命令接口``：

又叫做批处理命令接口，适用于批处理系统，不能直接干预作业的运行，应该事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给系统。

![image-20220315210430897](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315210430897.png)

##### 库函数和系统调用的区别



![image-20220315210610630](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315210610630.png)

![image-20220315210809852](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315210809852.png)

##### 什么功能要用到系统调用？

![image-20220315210840348](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315210840348.png)

##### 系统调用的过程

![image-20220315211458265](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315211458265.png)

![image-20220315211549748](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315211549748.png)



### 操作系统的体系结构

![image-20220315211907834](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315211907834.png)

如果把与硬件联系最紧密的放在内核，叫做微内核，如果把进程管理等功能也放在内核态，叫做大内核。

![image-20220315211955935](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315211955935.png)

#### 大内核/单内核/宏内核

#### 微内核

![image-20220315212235217](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212235217.png)

![image-20220315212304905](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212304905.png)

### 知识回顾

![image-20220315212402920](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212402920.png)

![image-20220315212714459](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212714459.png)

#### 操作系统机制在古代的应用

![image-20220315212759682](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212759682.png)

##### 特权指令和非特权指令

![image-20220315212842562](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212842562.png)

![image-20220315212906099](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212906099.png)

##### 内核态-->用户态

![image-20220315212957931](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315212957931.png)

##### 用户态-->内核态（异常）

![image-20220315213039419](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315213039419.png)

##### 用户态-->内核态（系统调用）

![image-20220315213241680](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315213241680.png)

##### 用户态-->内核态（外中断）

![image-20220315213338646](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220315213338646.png)

## 进程管理

### 进程和线程

#### 进程的概念

> 程序是静态的，就是存放在磁盘里的可执行文件，是一系列的指令集合。
>
> 进程是动态的 ，是程序的一次执行过程。
>
> 同一个程序多次执行会对应多个进程。

![image-20220316143226543](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316143226543.png)

####  进程的组成

##### PCB

人活着的时候一系列的信息就是身份信息，进程在进程活着的时候就是进程信息，由PCB块管理。

![image-20220316160247433](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316160247433.png)

![image-20220316160606273](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316160606273.png)

![image-20220316160707071](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316160707071.png)

![image-20220316160739200](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316160739200.png)

##### Linux中的PCB

![image-20220316160840625](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316160840625.png)

![image-20220321201004358](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321201004358.png)

##### 程序段和数据段

![image-20220316162856981](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316162856981.png)

![image-20220316163027055](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163027055.png)

#### 进程的特征

![image-20220407100103672](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407100103672.png)

![image-20220316163209437](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163209437.png)

##### 动态性

##### 并发性

##### 独立性

##### 异步性

##### 结构性

![image-20220316163237154](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163237154.png)

#### 进程的状态和组织方式

#### 进程的状态

##### 创建态

![image-20220316163439835](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163439835.png)

##### 就绪态

![image-20220316163517205](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163517205.png)

##### 运行态

![image-20220316163602098](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163602098.png)

##### 阻塞态

进程2发出指令，输出数据到打印机，但是打印机很忙，正在为别的进程服务。在打印机空闲之前，进程无法再往下执行。

![image-20220316163646247](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163646247.png)

进程2进入阻塞态，cpu把资源分配给另外一个就绪的进程。

![image-20220316163750819](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163750819.png)



![image-20220316163815855](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163815855.png)

等到进程1运行完了之后，发送一个exit，进入终止态。

![image-20220316163855149](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316163855149.png)

##### 终止态

![image-20220316165358793](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316165358793.png)

##### 进程状态的转换

1

![image-20220316165650273](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316165650273.png)



2.发现一个进程运行太久了，发出时钟信号

![image-20220316165726108](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316165726108.png)

![image-20220607103804990](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220607103804990.png)

##### 总结

![image-20220316165856773](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316165856773.png)

#### 进程的组织方式

##### 链接方式

![image-20220316170057102](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170057102.png)

![image-20220316170119897](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170119897.png)

##### 索引方式

![image-20220316170157029](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170157029.png)

#### 进程控制

##### 主要功能

![image-20220316170333590](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170333590.png)

##### 如何实现进程控制

![image-20220316170413212](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170413212.png)

![image-20220316170606622](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170606622.png)

###### 原语的原子性

![image-20220316170758334](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170758334.png)

如果两个特权指令允许用户程序使用，那就收不到中断信号，会让一个程序一直运行。

![image-20220316170911495](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316170911495.png)

###### 创建原语

![image-20220316171234748](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316171234748.png)

###### 撤消原语

![image-20220316171616896](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316171616896.png)

子进程父进程

比如一个父进程有8GB运存，但是把其中的50MB分给A，100MB分给B，等子进程结束了，再把资源还给父进程。

![image-20220316171401476](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316171401476.png)

###### 阻塞原语，唤醒原语

![image-20220316171829467](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316171829467.png)

###### 切换原语

运行环境信息：进程上下文，进程运行过程当中，寄存器里面存储的那些中间结果，进程下处理机的时候，需要把他的中间结果保存到pcb中，

![image-20220316171918992](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316171918992.png)

![image-20220316172105857](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316172105857.png)

![image-20220316172222746](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316172222746.png)

![image-20220316172233163](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316172233163.png)

![image-20220316172255220](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316172255220.png)

![image-20220316172350182](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316172350182.png)

![image-20220316172431049](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316172431049.png)

#### 进程通信

![image-20220316173116582](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316173116582.png)

![image-20220316173425269](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316173425269.png)

![image-20220316173822912](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316173822912.png)

##### 共享存储

![image-20220316174109501](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174109501.png)

![image-20220316174149103](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174149103.png)

![image-20220316174302815](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174302815.png)

##### 消息传递

![image-20220316174405221](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174405221.png)

###### 直接通信方式

![image-20220316174528085](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174528085.png)

![image-20220316174710138](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174710138.png)

![image-20220316174749450](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316174749450.png)

###### 间接通信方式

![image-20220316174916294](C:/Users/CAP/AppData/Roaming/Typora/typora-user-images/image-20220316174916294.png)

##### 管道通信

管道通信要求读写数据是先进先出的，FIFO;循环队列

共享存储是随意读写。

![image-20220316175243193](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316175243193.png)

![image-20220316175546614](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316175546614.png)

##### 回顾

![image-20220316175647453](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316175647453.png)

#### `线程`

##### 线程的概念

###### 什么是线程？为什么引入线程？

![image-20220407101914077](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407101914077.png)

![image-20220407102140495](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407102140495.png)

![image-20220407102634549](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407102634549.png)

![image-20220407103109699](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407103109699.png)

##### 引入线程有什么变化

![image-20220407102609188](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407102609188.png)

![image-20220407103611025](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407103611025.png)

![image-20220407102830791](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407102830791.png)

##### 线程的实现方式和多线程模型

###### 用户级线程

![image-20220407104101891](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407104101891.png)

![image-20220407104044806](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407104044806.png)

> 用户级线程是应用程序通过线程库来管理的。线程切换在用户态下就能完成，操作系统只能看见进程的存在，意识不到线程的存在。

![image-20220407104614363](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407104614363.png)

![image-20220407104647760](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407104647760.png)

###### 内核级线程

![image-20220407104758696](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407104758696.png)

CPU变态是有很大开销的

![image-20220407104854041](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407104854041.png)

###### 一对一模型

![image-20220407105056022](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407105056022.png)

###### 多对一模型

![image-20220407105307832](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407105307832.png)

###### 多对多模型

![image-20220407105545331](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407105545331.png)

![image-20220407105604224](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407105604224.png)

### 进程同步、互斥

#### 进程同步

> 异步性

![image-20220316204223971](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316204223971.png)

![image-20220316204329027](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316204329027.png)

#### 进程互斥

![image-20220316204509904](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316204509904.png)

![image-20220316204739018](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316204739018.png)

![image-20220316204854865](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316204854865.png)

#### 回顾

空闲让进，忙则等待，有限等待，让权等待。

![image-20220316204938464](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316204938464.png)

#### 进程互斥的软件实现

##### 如果没有进程互斥

![image-20220316205315443](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316205315443.png)

##### 单标志法

![image-20220316205553539](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316205553539.png)

如果谦让之后对方一直不使用这个资源，临界区空闲，违反了空闲让进规则

![image-20220316205716229](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316205716229.png)

##### 双标志先检查法

如果并发执行，P0进程执行到第二句的时候，刚好切换到P1进程，P1进程执行到第三句，刚好切换到P0进程。会出现两个进程同时进入临界区的情况。

![image-20220316210044995](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316210044995.png)

![image-20220316211756680](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316211756680.png)

##### 双标后检查法

![image-20220316211912792](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316211912792.png)

##### Peterson算法

如果是16278

![image-20220316212116805](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316212116805.png)



![image-20220316212323751](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316212323751.png)

![image-20220316212419085](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316212419085.png)

##### 回顾

![image-20220316212526539](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316212526539.png)

#### 进程互斥的硬件实现方法

##### 中断屏蔽

![image-20220316212851540](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316212851540.png)

##### TestAndSet指令

![image-20220316213427396](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316213427396.png)

##### Swap指令

![image-20220316213609035](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316213609035.png)

##### 回顾

![image-20220316213654351](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316213654351.png)

#### 信号量机制

设置了唤醒和等待，解决了让权等待。

![image-20220316215050180](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316215050180.png)

##### 整形信号量

> 用一个整数型的变量，作为信号量，用来表示系统中某种资源的数量。

![image-20220316215255750](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316215255750.png)

> 因为使用了原语，所以不会出现进程进入wait,另外一个进程也进入wait的情况。所以检查和上锁一气呵成，避免了并发，异步导致的问题。

![image-20220316215404642](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220316215404642.png)

##### 记录型信号量--semaphore

> 之前的整形信号量机制有一点的缺点，系统中只有一个资源被P0正在使用，但是如果这时候进程调度P1，P1只会忙等。不满足让权等待。
>
> 使用记录型信号量的之后，如果发现资源不够，进入到if语句里面，就会执行block原语，自动放弃处理机，将自己的状态变为阻塞状态，再将自己插入到等待队列中。

结构体中的等待队列，指向在等待的进程。



![image-20220320170200586](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320170200586.png)

###### 例子

刚开始打印机资源为2，等待队列为空

![image-20220320172709191](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320172709191.png)

执行P0进程时，P0进程用wait申请资源，value由2减为1

![image-20220320172915653](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320172915653.png)

切换到P1进程的时候

![image-20220320172945149](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320172945149.png)

接下来，切换到P2进程，P2执行wait操作的时候，首先还是会将Value进行-1的操作,value<0时，会自动的执行block原语，也就是把自己阻塞的原语，P2进程会被挂到等待队列里。S.Value=-1,表示有一个进程在等打印机资源，刚刚好是负数的绝对值。

![image-20220320173227143](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320173227143.png)

P3进程同P2进程。

![image-20220320173251613](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320173251613.png)

假设此时进程调度的P0,P0使用完打印机之后，执行Signal操作，在Signal原语中，发现S.Value还是<=0的，这时候会执行WakeUp原语，唤醒在队列中的第一个等待进程，也就是P2。并且把P2由阻塞变成就绪，并且把p0分配到的资源给P2,

![image-20220320173532762](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320173532762.png)

##### 回顾

![image-20220320170352174](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320170352174.png)

#### 用信号量机制实现进程的同步、互斥、前驱

![image-20220320174009652](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320174009652.png)

##### 实现进程互斥

系统中的某一些资源是必须互斥访问的，而访问这种系统的那段代码叫做临界区，所以既然资源需要互斥访问，所以同一时刻只能有一个资源进入临界区。

设置初值为1.

![image-20220320200556665](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320200556665.png)

##### 实现进程同步

在操作系统中，进程都是并发的进行，代码的执行先后顺序是不可预知的，但是有的时候代码的执行顺序又必须按照我们想要的顺序来执行，这时候就需要实现进程同步，解决进程并发的异步性。

假设代码2必须在代码4之前运行：

前V后P。在前操作之后执行V，在后操作之前执行P。

在2之后执行V，在代码4之前执行P。

设置初值为0.

###### 前V后P是什么？

![image-20220320201602434](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320201602434.png)

##### 进程前驱（多级同步）

> 只有S1执行了之后，才能执行S2和S3,
>
> 只有S2执行了之后，才能执行S4和S5
>
> 只有S3,S4,S5执行了之后，才能执行S6.
>
> 分析：这里有很明显的先后关系，都是同步关系。所以先考虑设置同步信号量，以S1对S2为例子：
>
> 设置一个同步信号量a=0,因为如果S1没执行的话，肯定不会执行S2.需要S1执行之后，改变a的值。
>
> 根据前操作之后V，后操作之前P
>
> P1(){
>
> S1;----前操作
>
> V(a);
>
> V(b);
>
> }
>
> P2(){
>
> P(a);
>
> S2;----后操作
>
> }



![image-20220320202100456](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320202100456.png)

![image-20220320202119447](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320202119447.png)

##### 总结

![image-20220320202500098](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320202500098.png)

#### 生产者-消费者问题---同步，互斥的综合问题

![image-20220321130019677](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321130019677.png)

> 问题分析：
>
> 回顾同步：同步也称制约关系。是为了完成某种任务而建立的两个或多个进程。进程因为需要协调工作次序而产生的制约关系。
>
> 缓冲区没满的时候，生产者才生产，否则必须等待。属于制约关系，所以属于同步
>
> 缓冲区不空的时候，消费者才取出产品，否则必须等待。属于制约关系，所以属于同步

![image-20220321124700128](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321124756895.png)

消费者把数据往外读之后，如果此时生产者是属于阻塞状态的，消费者会将生产者唤醒，处于就绪状态，但是处于就绪状态并不意味着生产者立即往里写数据，也可能是消费者继续往外读出数据。

![image-20220321130329440](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321130329440.png)

![image-20220321130648350](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321130648350.png)

> 缓冲区是临界资源，各进程必须互斥的访问。
>
> 生产者同时写入，会引发数据覆盖。

![image-20220321130757324](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321130757324.png)

> 在前面的动作完成之后，需要对同步信号量执行V操作，在后面的动作开始之前，需要对同步信号量执行P操作。
>
> 缓冲区里有产品是生产者进程触发的，也就是说当生产者往缓冲区放入产品，就需要对full信号量进行V操作，而当消费者从缓冲区里取走数据之前，需要对full信号量执行一个P操作。
>
> 前V后P：前操作（缓冲区没空）之后，后操作（消费者消费）之前。
>
> 前操作（缓冲区没满）之后，后操作（生产者生产）之前。

![image-20220321131004525](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220321131004525.png)

> 同步信号量对应资源初始值问题：
>
> 先看上面同步关系，消费者进程在消费之前需要消耗什么资源呢？消耗的是产品， 所以它的P操作其实是在申请一个产品，申请一个数据，full对应的资源是产品的数量，也就是非空缓冲区的数量，有题目中能分析，刚开始的时候，缓冲区都是空的，产品的数量是0.所以full的初始值为0；
>
> 再看第二个同步信号量empty，生产者每消耗一个产品就需要消耗一个空闲的缓冲区，因此empty这种同步信号量对应的资源，就应该是空闲缓冲区的资源，它的数量就是空闲缓冲区的数量，当一个消费者进程取走了一个产品，做了消费的动作之后，就释放一个产品也就是空闲的缓冲区。由题可知，缓冲区初始值为n。所以empty初值为n.

##### 代码实现

![image-20220324095437420](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324095437420.png)

![image-20220324095318466](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324095318466.png)

> 思考：
>
> 1.能否改变相邻PV操作的顺序？
>
> 答案如图
>
> 2.生产一个产品和使用产品，能不能放到临界区代码（PV之间）？
>
> 答：逻辑上可以，但是临界区代码不宜过多，会降低系统性能。

![image-20220324110119191](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324110119191.png)



#### 多生产者-多消费者问题---复杂的同步关系

不同类别的生产者，和不同类别的消费者

![image-20220416162800947](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416162800947.png)

![image-20220416163755772](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416163755772.png)

> 能不能考虑不用互斥信号量mutex解决问题？

![image-20220416164155410](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416164155410.png)

如果只有一个盘子的话，是没问题的，但是如果盘子能放两个，临界资源有2的话，会导致两个进程同时进入缓冲区

![image-20220416165331465](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416165331465.png)

![image-20220416165444369](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416165444369.png)

##### 总结

如果这个题没有橘子和苹果的区别，只有水果。儿子和女儿也不挑剔的话。

那是不是意味着,女儿拿走水果，可以引发妈妈把水果放盘子里，也可以引发爸爸把水果放盘子里，儿子也是。这样写出来是四对同步关系。

正确的分析应该从事件的角度考虑。盘子变空的事件，和放入水果的事件。

![image-20220416170722459](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416170722459.png)

#### 吸烟者问题---生产多产品的单生产者

供应者放第一个抽烟者需要的材料在桌子上：

![image-20220416173734671](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416173734671.png)

第一个抽烟者抽完烟之后，会告诉供应者，自己抽完烟了，供应者就会再拿出材料放到桌子上

![image-20220416173833912](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416173833912.png)



![image-20220416174119610](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416174119610.png)

![image-20220416174603463](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416174603463.png)

![image-20220416174827234](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416174827234.png)

##### 回顾

![image-20220416174903603](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416174903603.png)

#### 读写者问题---复杂的互斥问题

> 允许多个读者同时对文件执行读操作。
>
> 只允许一个写者往文件中写信息。---避免数据覆盖
>
> 任一写者在完成操作之前，不允许其他读者和其他写者工作。---避免读到脏数据
>
> 写者执行写操作之前，应让读者和写者全部退出。避免数据覆盖和读到脏数据

![image-20220416175546074](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416175546074.png)

第一步：先分析互斥关系，显然读者和写者，写者和写者有互斥关系，所以在写之前加锁，写完了解锁，读之前加锁，读完了解锁，这样就能做到读写互斥了，但是读和读，不能同时进行了。如何解决呢？

![image-20220416180536430](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416180536430.png)

这样解决是有问题的：

![image-20220416181517256](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416181517256.png)

![image-20220416181826993](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416181826993.png)

还需要设置一个互斥信号量来解决读读问题：

​	![image-20220416181915300](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416181915300.png)

此时读进程是优先的，为什么这么说呢？因为当读进程进入内部的p(rw)的时候，保证读写者互斥的时候，会对rw执行--操作，当调度到写进程时，rw是0，此时放弃处理机，如果有读进程源源不断的读的时候，写进程就会饿死。

![image-20220416181957490](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416181957490.png)

下面来实现写优先：

![image-20220416183242168](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416183242168.png)

![image-20220416183524643](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416183524643.png)

##### 回顾

![image-20220416183728016](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416183728016.png)

#### 哲学家进餐---解决死锁问题

> 哲学家只做两件事情，要么在思考，要么在进餐。
>
> 哲学家i左边的筷子编号为i
>
> 右边筷子编号为（i+1）%N(N个哲学家)

![image-20220324111554712](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324111554712.png)

> 这样的问题是：如果一号哲学家拿了一个筷子，之后切换到二号，以此类推，这样下去每个哲学家都只拿一根筷子。
>
> 执行第二个P操作的时候，都会被阻塞。都在等待其他人放下筷子，发生死锁。

![image-20220324111759610](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324111759610.png)

![image-20220324112028323](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324112028323.png)

> 如何避免？
>
> 方式1：

![image-20220324112330572](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324112330572.png)

> 方式2

![image-20220324113257868](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324113257868.png)

![image-20220324113827609](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324113827609.png)



> 方式3

![image-20220324112529532](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324112529532.png)

第一种情况：0号哲学家拿起左边的筷子，再拿起右边的筷子，拿完了之后释放mutex。这时候二号哲学家也拿起左边的筷子和右边的筷子。

![image-20220324112707233](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324112707233.png)

第二种情况：如果0号哲学家拿完了筷子，这时候切换到了1号哲学家，1号哲学家上锁了，此时切换到2号哲学家，2号哲学家卡着进不去，即使左边和右边的筷子都在，也没办法拿到筷子。

![image-20220324112830353](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324112830353.png)

第三种情况，0号哲学家拿完了之后，释放了mutex,此时四号哲学家拿起了左边的筷子，但是右边的筷子拿不到，也会发生阻塞。

![image-20220324113022628](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324113022628.png)

##### 回顾

![image-20220324113054696](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324113054696.png)



### 处理机调度

#### 基本概念

![image-20220407105835413](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407105835413.png)

#### 三个层次

##### 高级调度

![image-20220407110154725](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407110154725.png)

##### 低级调度

![image-20220407110235203](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407110235203.png)

##### 中级调度

![image-20220407111411857](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407111411857.png)

![image-20220407110544993](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407110544993.png)

![image-20220407111239069](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407111239069.png)

![image-20220407111337383](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407111337383.png)

#### 挂起状态和七状态模型

可能会把一个就绪状态的进程放到外存当中，这个进程就进入了就绪挂起状态。需要继续执行就被激活。

一个阻塞状态的进程放到外存当中，这个进程就进入了阻塞挂起状态。也会被重新激活到阻塞态。但是也有可能阻塞挂起的进程当它等待的阻塞事件发生的时候，直接进行就绪挂起的状态。

可能会把一个运行态的进程，下处理机的时候会被放到就绪挂起的状态。

![image-20220407111109943](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407111109943.png)

#### 进程调度的时机

![image-20220407114808926](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407114808926.png)

> 进程在操作系统内核程序临界区中：
>
> 如果进程在访问操作系统内核程序临界区，如果被调度走了的话，比如此时临界资源是就绪队列，此时进程被调度走了，但是临界资源被上锁了，此时就绪队列没有其他进程能访问，就会影响到操作系统内核的工作。

![image-20220407113131632](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407113131632.png)

![image-20220407113526467](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407113526467.png)

> 进程在普通程序临界区中，是可以发生进程调度的，
>
> 比如打印机，是一个慢速设备，如果一直不允许进行进程调度的话，就会导致cpu一直空白
>
> 访问普通临界区不会影响到操作系统内核的工作。

![image-20220407113633467](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407113633467.png)

![image-20220407113651225](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407113651225.png)

##### 进程调度的方式

![image-20220407115059348](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407115059348.png)

##### 进程的切换的过程

![image-20220407115939811](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407115939811.png)

![image-20220407120044824](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407120044824.png)

#### 调度算法的算法的评价指标

##### CPU利用率

![image-20220407171330319](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171330319.png)

##### 系统吞吐量

![image-20220407171353057](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171353057.png)

##### 周转时间

![image-20220407171539794](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171539794.png)

![image-20220407171629486](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171629486.png)

##### 等待时间

![image-20220407171745493](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171745493.png)

##### 响应时间

![image-20220407171802915](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171802915.png)

![image-20220407171814818](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407171814818.png)

#### 调度算法

![image-20220407172019417](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407172019417.png)

##### FCFS

> 先来先服务3
>
> /4是进程个数

![image-20220407190052549](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407190052549.png)

带权周转时间越大，体验越糟糕，明明运行的时间很短，但是要等特别久

![image-20220407190308874](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407190308874.png)

比如买奶茶，一个人买奶茶只要一分钟，但是前面那个人要30杯奶茶...所以你的带权周转时间很长

![image-20220407190547397](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407190547397.png)

##### SJF

> 短作业优先之非抢占式

![image-20220407191124881](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191124881.png)

> 短作业优先之抢占式（最短剩余时间优先算法SRTN）

![image-20220407191501029](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191501029.png)

![image-20220407191511041](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191511041.png)

![image-20220407191557643](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191557643.png)

![image-20220407191750796](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191750796.png)

![image-20220407191813139](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191813139.png)

![image-20220407191843274](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191843274.png)

##### HRRN

> 高响应比优先

![image-20220407191925624](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407191925624.png)

![image-20220407192306472](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407192306472.png)

![image-20220407192401493](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407192401493.png)

![image-20220407192412695](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407192412695.png)

![image-20220407192459604](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220407192459604.png)

##### 时间片轮转算法（RR）

> 时间片调度算法作用分时操作系统，更关心系统的响应时间

![image-20220414095435199](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414095435199.png)

![image-20220414095800952](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414095800952.png)

![image-20220414095927564](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414095927564.png)

> 时间片为5的情况

![image-20220414100039164](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414100039164.png)

![image-20220414100924272](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414100924272.png)

![image-20220414100955853](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414100955853.png)

##### 优先级调度算法

> 非抢占式的优先级调度算法

![image-20220414101323507](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414101323507.png)

> 抢占式的优先级调度算法

![image-20220414102251835](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414102251835.png)

> 动态优先级：和高响应比优先算法有点像

![image-20220414102606224](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414102606224.png)

![image-20220414102707992](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414102707992.png)

![image-20220414102754216](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414102754216.png)

##### 多级反馈队列调度算法

`1`.给每一级别的时间片都不一样，比如本例中，第一级队列分配的时间片是1，第二级队列分配的时间片是2，第三级队列分配的时间片是4。

`2`.如果有新进程到达的话，会优先进入优先级最高的，也就是第一级队列的队尾。

刚开始0时刻P1到达，所以会放入第一级队列，队列没有其他的，先给P1调度。

![image-20220414102927925](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414102927925.png)

`3`P1用完时间片还未结束，会进入下一级队列的队尾。此时P1运行完一个时间片之后，P2紧随其后到达，所以P2插入第一级队列。

![image-20220414103007234](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103007234.png)

`4`此时P2在第一级队列，P1在第二级队列，因为有更高级别的没有处理完，所以不会处理更低级别的P1.

此时还是P2运行一个单位时间片。

![image-20220414103037895](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103037895.png)

`5`: P2运行完成，插入第二级队列队尾，P2还剩下3，P1还剩下 7 ，此时一级队列为空，P3进程还未到达，所以处理第二级队列，

P1运行两个时间片时间，P1放入下一级。

![image-20220612203200297](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220612203200297.png)

`6`此时运行了P1的一个时间片，P2的一个时间片，P1的两个时间片，当P2上二级队列再运行一个时间片的时候，刚刚好是时刻5，此时P3到达一级队列

![image-20220414103109354](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103109354.png)

`7`直接抢占，但是不会把P2放到下一级队列，P3运行完一个时间片，调出内存。

P2再上二级队列使用CPU，再使用两个时间片，P2运行完毕，调出内存

![image-20220414103141010](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103141010.png)

`8`P1运行完四个单位，一共运行了7个单位时间，但是P1已经在最下面的队列了，所以此时不能往下了，只能被放入到最下面，也就是第三级队列的队尾，再次被调度。P1完成再调出。

![image-20220414103204106](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103204106.png)

![image-20220414103221593](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103221593.png)

![image-20220414103405348](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103405348.png)

##### 总结

![image-20220414103530005](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414103530005.png)

### 管程

![image-20220414104057430](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414104057430.png)

#### 管程的定义和基本特征

> 管程的基本特征中
>
> 第一句话和第二句话是什么意思？
>
> 管程中的共享数据只能由管程的过程访问。
>
> 管程其实就是面向对象的类。

![image-20220414105217606](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414105217606.png)

#### 管程解决生产者消费者问题

![image-20220414105729298](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414105729298.png)

![image-20220414105755469](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414105755469.png)

#### Java类似管程机制

![image-20220414105848210](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414105848210.png)

#### 总结

![image-20220414105912657](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414105912657.png)

### 死锁

#### 死锁的概念

##### 什么是死锁

![image-20220414110154782](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414110154782.png)

![image-20220414110306522](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414110306522.png)

##### 死锁、饥饿、死循环

> 解决死循环是程序员的事情
>
> 解决死锁和饥饿是操作系统的事情

![image-20220414110554868](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414110554868.png)

##### 死锁产生的条件

> 互斥条件：必须互斥的使用临界资源
>
> 不剥夺条件：进程所获得的资源在未使用之前，不能由其他进程强行夺走，只能主动释放
>
> 请求和保持条件：进程已经保持了至少一个资源，但是又提出新的资源请求
>
> 循环等待条件：存在一种进程资源的循环等待。A等B，B等C，C等A
>
> 为什么说循环等待是死锁的充分不必要条件？
>
> 因为如果有同类资源，即使循环等待了，但是也可能不会导致死锁。

![image-20220414200642913](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414200642913.png)

##### 什么时候会发生死锁

![image-20220414202010815](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414202010815.png)

![image-20220414202253735](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414202253735.png)

#### 预防死锁

只要破坏四个条件的某一个条件，都不会发生死锁。

对互斥的争用资源。

进程的资源只能主动释放，不可以强行剥夺

保持某些资源不放，请求别的资源

存在循环等待链。

##### 破坏互斥条件

SPOOLing技术，例如加一个输出进程，进程1和2看来，输出进程就是一个共享的设备，之后由输出进程慢慢交给打印机即可。

![image-20220416190301650](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416190301650.png)

##### 破坏不剥夺条件

![image-20220416190555392](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416190555392.png)

##### 破坏请求和保持

可能导致进程饥饿，如果A要资源1，C要资源1，2，如果资源A源源不断，C就会饥饿

![image-20220416190728796](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416190728796.png)

##### 破坏循环等待

P3只能申请更大的，8，9，10肯定是空闲的，至少P3能运行。不会导致所有进程的死锁。

![image-20220416191114970](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416191114970.png)

#### 银行家算法（避免死锁）

![image-20220416191700708](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416191700708.png)

![image-20220416191745721](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416191745721.png)

![image-20220416191813180](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416191813180.png)



![image-20220416191950193](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416191950193.png)

依次对比：第一轮：

![image-20220416192212499](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192212499.png)

依次对比：第二轮

![image-20220416192259206](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192259206.png)



![image-20220416192346868](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192346868.png)



考试手算：

![image-20220416192500364](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192500364.png)

![image-20220416192513945](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192513945.png)

![image-20220416192558627](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192558627.png)

假设：

![image-20220416193512920](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416193512920.png)

![image-20220416192748429](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192748429.png)

![image-20220416192843596](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220416192843596.png)

#### 死锁的检测和解除

![image-20220418110740050](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418110740050.png)

##### 死锁的检测

![image-20220418140524183](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418140524183.png)

### PCB组织方式实验

#### 线性表方式

数组最大的优势是快速随机的去查找，但是在删除和插入耗费的时间复杂度很大，也不利于去反应队列的概念。

#### 链接表方式

能反应链式队列的情况，在插入和删除的时候，几乎可以让时间复杂度等于1，但是链式和数组的优缺点是完全相反的。

所以提出了索引表的方式。

#### 索引表的方式

增加了空间复杂度，以空间换时间。很好结合了顺序结构的优势，和链式结构的优势。所以我们研究的是索引表的组织方式应该采用哪一种最好？

PCB表是一个结构体数组

就绪索引表是一个静态链表，如何去定义？



![image-20220322110720422](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220322110720422.png)

指针的结构如何去定义？最好是有一个头指针，一个尾指针，一个记录长度。

为什么指向表尾？比如PCB中多了一个阻塞进程，所以应该插入到阻塞索引表的表尾去，希望索引表的表尾，能快速指向PCB表，但是如果没有表尾指针，从表头找到表尾，是需要花时间的。

> 运行指针是直接指向PCB的
>
> 就绪表指针，是指向一个就绪索引表。

![image-20220322110955936](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220322110955936.png)

从阻塞转到就绪

删除表头，表头指针下移，就绪表+1.头不断后缩，尾巴也要跟上

![image-20220322111640850](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220322111640850.png)

假设一个正在执行的进程，要转为阻塞状态

首先要找到正在执行的进程，找到4号进程，把4号进程的状态改为阻塞，改完之后，进入到阻塞索引表。找到索引表表尾。

由于PCB闲置了，会进程调度，把就绪队列中的首个进程（1号进程），从就绪表删除，增加为运行状态，让运行指针指向PCB中的1.

然后就绪表指针下移。

![image-20220322111727403](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220322111727403.png)

### 上课例题

#### 例题1

![image-20220324100818280](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324100818280.png)

> 分析：保证三个进程对y,z要互斥访问。
>
> 1，3对y 有互斥访问的要求



![image-20220324101344543](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324101344543.png)

![image-20220324101042109](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324101042109.png)

2，3互斥

![image-20220324101318430](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324101318430.png)

这样写1和2都互斥了，1执行2不能执行

![image-20220324101539943](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324101539943.png)

改：

![image-20220324101909854](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220324101909854.png)

## 内存管理

### 内存的基础知识

![image-20220421102115847](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421102115847.png)

这个8G就是内存容量，64G是外存容量。

![image-20220421102143120](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421102143120.png)

这个32G就是内存容量

![image-20220421102321339](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421102321339.png)

![image-20220421102328607](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421102328607.png)

> 内存可以存放数据，程序执行前需要先放到内存中才能被CPU处理---缓和CPU和硬盘之间的速度矛盾

![image-20220421102602467](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421102602467.png)

> 按照字节编址，一共有2的32次方个字节，所以一共有2的32次方个小房间

![image-20220421103120090](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421103120090.png)

> 红色的是操作指令，比如是要执行数据传送操作，第二个00000011是地址为3的，第三个是01001111，意思是把地址为01001111的数据，也就是10，传送到00000011中，也就是地址为3

![image-20220421104525309](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421104525309.png)

> 红色的是操作指令，比如是要执行加法操作，第二个00000011是地址为3的，最后一个是参数，把地址为3的值+1 

![image-20220421104259793](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421104259793.png)



![image-20220421104719897](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421104719897.png)

#### 指令的工作原理

可执行文件也成为装入模块，把可执行文件放入内存里，就可以执行这个程序了。

这是物理地址的情况，起始地址从0开始：

![image-20220421105415249](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421105415249.png)

逻辑地址：起始地址不一定从0开始，本例从100开始：

如果想写到79的内存空间，但是79的内存空间如果是分配给其他进程的呢？	

其实正确的意思是，要写到100+79的位置，也就是179这个位置。

所以问题来了，如何将指令中的逻辑地址转换为物理地址？？有三种策略，绝对装入，可重定位装入（静态重定位），动态运行时装入（动态重定位）。

![image-20220421105004018](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421105004018.png)

#### 三种装入方式

##### 绝对装入

如果知道装入模块要从100的地方开始存放...

如果这个程序在另外一个电脑上运行，但是另外一个电脑的100号位置不能让他存放，怎么办？所以这种方式特别的不灵活。

![image-20220421110100683](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421110100683.png)

##### 可重定位装入

在程序执行之前，就给他分配其要求的全部内存空间。在运行期间不能移动，也不能再申请，不然地址的指向又会发生错误。

![image-20220421110439550](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421110439550.png)

##### 动态运行时装入

使用一个重定位寄存器，存放装入模块存放的起始地址。

![image-20220421111120305](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421111120305.png)

![image-20220421111303529](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421111303529.png)

#### 三种链接方式

##### 静态链接

在程序运行之前，就把目标模块连接成一个完整的可执行文件。

![image-20220421111359356](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421111359356.png)

##### 装入时动态链接

这个进程的完整的逻辑地址是一边装入一边形成的

![image-20220421111456590](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421111456590.png)

##### 运行时动态链接

只有我们需要用到某个模块的时候才把那个模块调入内存。在装入的时候，再把他链接好。

![image-20220421111737775](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421111737775.png)

![image-20220421111932280](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421111932280.png)

### 内存管理的概念

#### 内存空间的分配和回收

![image-20220421112204393](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112204393.png)

#### 内存空间的扩展

![image-20220421112305317](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112305317.png)

#### 地址转换

![image-20220421112432489](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112432489.png)

#### 内存保护

##### 设置上下限寄存器

![image-20220421112535956](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112535956.png)

##### 重定位寄存器

![image-20220421112743662](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112743662.png)

![image-20220421112815542](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112815542.png)

### 覆盖与交换(空间扩充)

![image-20220421112946509](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421112946509.png)

#### 覆盖技术

>  用来解决程序大小超过物理内存总和的问题

![image-20220421114034972](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421114034972.png)

A调用分别B和C，不会同时存在B和C，因为要在不同的时间段内调用。



![image-20220421114355928](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421114355928.png)

#### 交换技术

在内存空间紧张的时候，系统将内存中某些进程暂时换到外存中，把外存一些具备运行条件的进程换入内存中。

在外存中有文件区和对换区，被换出的进程的数据就在对换区中。

![image-20220421115658229](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421115658229.png)

![image-20220421115848246](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421115848246.png)

### 连续分配管理(分配回收)

连续分配：为用户进程分配的必须是一个连续的内存空间。

![image-20220421120334437](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220421120334437.png)

#### 单一连续分配

##### 内部碎片

在单一连续分配分配方式中，内存被分为==系统区==和==用户区==。系统区通常位于内存的低地址部分，用户区存放用户进程相关数据。

内存中只能有一道用户程序。用户程序独占整个用户空间。无需进行内存保护，因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。

优点：实现简单，没有外部碎片（动态分区分配的时候补充）

缺点：有内部碎片（比如分配给某进程的内存区域中，有部分没被用上，这就是内存碎片。本来整个用户区都是给进程A的，还有很多空闲的，空闲的就是内部碎片）

![image-20220427214659453](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220427214659453.png)

#### 固定分区分配

将用户空间划分为若干个固定大小的分区。每个分区装入一个作业。

分区大小相等：缺点是 不够灵活，比如大进程在分区不够分，需要采用覆盖技术。小进程不需要那么大。

![image-20220427215041188](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220427215041188.png)

操作系统如何记录各个分区的空闲或者分配的情况？建立分区说明表：

为什么产生内部碎片，比如10M的进程，1~5不能满足，扫描的时候只有6能满足，但是6大了2MB.

![image-20220427215240664](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220427215240664.png)

#### 动态分区分配

![image-20220428110039402](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428110039402.png)

1.系统需要什么样的数据结构记录内存的使用情况？

空闲分区表，空闲分区链

![image-20220428112019109](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428112019109.png)

2.当很多个空闲分区都能满足需求，应该选择哪个分区进行分配？

此时的进程5，20MB,10MB,4MB都能满足要求。应该选择哪个？

![image-20220428112134863](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428112134863.png)

3.如何进行分区的分配与回收

**如何分配？**

假设采用空闲分区表：如果进程5需要4MB的内存空间，假设采用某种算法，从20MB空闲空间中，分出4MB给进程5

![image-20220428114930850](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428114930850.png)

假设采用空闲分区表：如果进程5需要4MB的内存空间，假设采用某种算法，从4MB空闲空间中，分出4MB给进程5，此时分区大小和申请的空间是相同的，需要把表项删除。如果是分区链的话，就删除一个结点。

![image-20220428115125027](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115125027.png)

**如何回收**

第一种情况：

如果进程4运行完了，后面紧跟着有10MB的空闲空间，把分区大小和起始地址改掉。

![image-20220428115305490](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115305490.png)

![image-20220428115343719](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115343719.png)

第二种情况：回收区的前面有一个相邻的空闲分区

假设进程3运行结束了，在进程3的前面有相邻的空闲分区，也进行合二为一

![image-20220428115429961](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115429961.png)

![image-20220428115529864](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115529864.png)

第三种情况：回收区的前后各有一个相邻的空闲分区。

假设此时的进程4被回收了，需要合并一整块的内存空间。

![image-20220428115620683](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115620683.png)

![image-20220428115836322](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115836322.png)

第四种情况：假设回收区的前后都没有空闲分区

假设进程2已经运行结束

![image-20220428115909529](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115909529.png)

![image-20220428115940206](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428115940206.png)

##### 外部碎片

![image-20220428120212079](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428120212079.png)

##### 紧凑技术

操作系统不时的对进程进行移动和整理，但这需要动态重定位寄存器的支持。而且相对费时。

![image-20220428120426367](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428120426367.png)

![image-20220428120448491](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428120448491.png)

##### 动态分区分配算法

###### 首次适应算法

顺着表头或者顺着链头依次查找，找到第一个满足分区的。

每次都从低地址开始查找，找到第一个满足要求的空闲分区。

![image-20220428120913057](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428120913057.png)

![image-20220428120907728](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428120907728.png)

![image-20220428121345718](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121345718.png)

###### 最佳适应算法

按照容量递增，依次链接，如果此时需要9MB，找到10MB的，如何10-9=1，再把1MB调到前面去。

![image-20220428121503779](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121503779.png)

![image-20220428121603514](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121603514.png)

![image-20220428121635310](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121635310.png)

###### 最坏适应算法

按照容量递减，依次链接。

如果此时需要3MB.

![image-20220428121725374](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121725374.png)

![image-20220428121801669](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121801669.png)

![image-20220428121827647](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121827647.png)

![image-20220428121842046](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428121842046.png)

###### 邻近适应算法

和首次适应算法不一样的地方在于，首次适应算法每次都是从头开始，但是邻近适应算法每次都是从上次分配的那个位置继续往后开始。

比如此例中的第一次要分配5MB，链表中只有6MB的满足他的要求。下次不会从4这位置开始，会直接从6往后查找。不需要花额外的时间对链表进行重新排列。

![image-20220502163801117](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502163801117.png)

![image-20220502164007913](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502164007913.png)

第二次要5MB.

![image-20220502164038650](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502164038650.png)

![image-20220502164046532](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502164046532.png)

![image-20220502164116124](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502164116124.png)

###### 对比

![image-20220502164220082](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502164220082.png)

### 非连续分配管理(分配回收)

![image-20220502164604778](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502164604778.png)



#### 基本分页存储管理

##### 什么是分页存储

`将内存空间`分为一个个大小相等的分区（比如每个分区4KB），每个分区是一个<font color='cornflowerblue'>**页框**</font>。

页框也叫（**页帧，内存块，物理块，物理页面**）。

每个页框有一个编号，编号从0开始，叫<font color='cornflowerblue'>**页框号**</font>。

页框号也叫（页帧号，内存块号，物理块号，物理页号）。

``将进程的逻辑地址空间``也分为与**<font color='cornflowerblue'>页框</font>**大小相等的一个个部分，将每一个部分称为<font color='cornflowerblue'>**页（页面）**</font>。每一个页面也有一个编号，即<font color='cornflowerblue'>**页号**</font>。页号也是从0开始。

![image-20220502165925400](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502165925400.png)

![image-20220502165946693](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502165946693.png)

##### 重要的数据结构---<font color='cornflowerblue'>页表</font>

如何保证进程不连续的分配到内存后还能正确执行？答：需要映射关系



![image-20220624180303381](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624180303381.png)

页表保存在内存中，就有一个对页表的寻址问题，一般会给页表分配连续的存储空间，这样我们找到一个页表，只需要知道页表的起始地址就好了，所以我们要保存页表的起始地址，或者叫基地址。具体保存在哪里，根据进程的状态有不同：

![image-20220624180350265](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624180350265.png)

逻辑地址如何映射物理地址呢？

给出了虚地址，我们首先要去找页表项，页表项记录了映射关系。要找到页表项，至少我们要知道页表在哪里？用什么来指示页表？

用页表的起始地址，页表的起始地址保存在哪里呢？根据进程的状态。位置有所不同。

页表寄存器中保存了页表的起始地址。我们如何去找呢？

答：用页表的起始地址，（**因为只有知道了页表的起始地址，才能顺序通过页号去遍历页表**）加上页号，

比如页表的起始地址是00，页号是1，此时我们就用页表的起始地址+页号1，这样我们就找到了页表项中页号为1的页表项，把页表项的页框号取出。再加上虚地址的页内地址，最终就得到了实地址。

![image-20220624185158617](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624185158617.png)

![image-20220502170301517](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502170301517.png)

> Q1:每个页表项多大？占几个字节？

页表项是进程的概念。

给出了物理内存是4GB,也就是2^32B。

给出了页面的大小，页面的大小是进程为了适应内存的页框设置的大小，所以能知道内存划分了多少个页框。

也就是2^32/2^12=2^20。个内存块（页框）

所以页框号（内存块号）0~2^20-1。

所以内存块号 需要 20bit表示。

所以页表项中，至少要3B表示块号。

![image-20220502170642902](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502170642902.png)

逻辑上有页号和块号，其实页表项是连续存放的，所以页号可以是隐含的，不占用存储空间。第i号页表项的地址X=3*i.

所以物理上页号是不占用存储空间，只需要存放块号。

![image-20220502180422120](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502180422120.png)

![image-20220502180642114](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502180642114.png)

> Q2:如何通过页表实现逻辑地址到物理地址的转换？

1. ``确定逻辑地址A的页号。``
2. ``找到P号页面在内存中的起始地址（需要查页表）上面已经提到过，J号内存块的起始地址=J*内存块大小``
3. ``确定逻辑地址A的页内偏移量``

![image-20220503201643704](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220503201643704.png)

##### 确定页号、页内偏移量

![image-20220503203038163](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220503203038163.png)

![image-20220503203538046](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220503203538046.png)

![image-20220509104928537](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220509104928537.png)

![image-20220509111745298](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220509111745298.png)

##### 基本地址变换机构

![image-20220512171813390](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512171813390.png)

经过上个小节。在分页存储管理当中，如果要把逻辑地址转换成物理地址，

要知道逻辑地址对应的页号，要知道逻辑地址对应的页内偏移量，知道逻辑地址对应的页面在内存中存放的位置，根据起始位置和页内偏移量，就知道最终的物理地址了。

![image-20220509112312586](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220509112312586.png)

###### 过程

地址变换机构的大致流程是这样的：

![image-20220509113252719](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220509113252719.png)

用文字具体描述一下这个流程：

![image-20220509113840599](C:/Users/CAP/AppData/Roaming/Typora/typora-user-images/image-20220509113840599.png)

![image-20220509113730340](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220509113730340.png)

> 看几个例题

为什么说页号2没越界？因为题目说了它能对应内存块号

![image-20220509183954274](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220509183954274.png)

例题2.如果隐含了页号

为什么除以3？因为块号占了三个字节。进程的一个页面是4KB，内存的页框也是4KB，一个页框放4KB/3B个页表项。

M号页的位置是X+3M,比如一号页，就是X+3*1

![image-20220511213522123](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220511213522123.png)

![image-20220511215220921](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220511215220921.png)

##### 具有快表的地址变换机构

在基本地址变换机构中，页表存放在内存中。

![image-20220512172836635](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512172836635.png)

把页表项的副本放到高速缓存中，就变成了快表，在内存中的页表项就变成了慢表。那能不能把页表全部放在高速缓存呢？

![image-20220512173233314](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512173233314.png)

![image-20220512173243155](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512173243155.png)

通过快表去访存的过程

![image-20220512194652381](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512194652381.png)

![image-20220512194715740](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512194715740.png)

用文字描述一下：

![image-20220512195046390](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512195046390.png)

那么引入快表，到底能节省多少时间呢？假设一个例子：

三种情况：

1.引入快表，但是有几率不命中，先访问快表，再访存

2.不引入快表

3.快表和慢表同时查找

![image-20220512195247615](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512195247615.png)

如何理解快表和慢表同时查找？

访存失败的情况，那个1s不算了

因为是同时访存的

![image-20220512203131719](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512203131719.png)

> 为什么TLB中只存放了页表的一部分就可以提升效能那么多？
>
> 因为局部性原理

局部性原理：

![image-20220512204302607](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512204302607.png)

![image-20220512204352712](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512204352712.png)

##### 两级页表

分页存储管理的逻辑地址结构是：页号（P）+页内偏移量（W）

页内偏移量也叫页内地址。

假设计算机系统按字节寻址，支持32位逻辑地址，采用分页存储管理，页面大小为4KB,页表项长度为4B.

==页面大小=2^12B。页内地址用12位表示，页表项的长度是4B。==

###### 单级页表存在的问题

![image-20220516201153823](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516201153823.png)

![image-20220516201105120](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516201105120.png)

![image-20220516201122485](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516201122485.png)

![image-20220516201255087](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516201255087.png)

如何做的呢？

2^32的空间，页面大小占4KB,页内地址就是12bit，页内偏移量也是12，所以有20位的页号，因为页面大小是4KB,

但是一个页表项是4B，一个页框能放1024个页表项。

现在思路是同时存1048575个页表项太多了，要拆开，怎么拆？

因为一个页框刚刚好1024个页表项，所以就1024个页表项这样拆，分为1024个小部分。 

![image-20220516203630443](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516203630443.png)

###### ==如何实现地址变换==

最左边的内存块号指的是，二级页表在内存的哪个位置
二级页表的内存块号指的是程序和代码存放在内存的哪个位置

流程是：

首先从页目录表中，也就是一级页号中，去内存找二级页表，比如途中的（0，3），意味着二级页表在内存中的位置是3号块，去3号块找到了二级页表的位置之后，通过读取二级页表的值，比如题目中的00000001，就意味着逻辑地址存放的位置是4号快。

![image-20220516205347061](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516205347061.png)

==解决问题2==

![image-20220516210814762](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516210814762.png)

###### 注意的细节

没有快表机构的话，二级页表访存三次（目录，二级页表，内存）

三级页表，四次

n，n+1

![image-20220516214051333](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516214051333.png)

![image-20220516214136262](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220516214136262.png)

### 基本分段存储管理(分配回收)

#### 分段

进程的地址空间，按照程序自身的逻辑关系划分为若干个段，每个段都有段名，编译程序会把段名转换为段号。

![image-20220517105119301](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517105119301.png)

逻辑地址结构就变成了：==段号和段内地址==

![image-20220517111008162](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517111008162.png)

#### 段表

段长可能每个段的长度都不一样，但是分页的话，每个页面的长度都是一样的

基本分段存储管理的段表由段号、段长、基址（段的起始地址）组成

![image-20220624182203920](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624182203920.png)

![image-20220517111507969](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517111507969.png)

#### 地址变换

红色的表示段号，黑色的表示段内地址

![image-20220517111915202](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517111915202.png)

##### 具体过程：

![image-20220517112942542](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517112942542.png)

#### 分段和分页的对比

``页是信息的物理单位，段是信息的逻辑单位``

``分页的用户进程的地址空间是一维的``

``分段的用户进程的地址空间是二维的``

![image-20220517113251315](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517113251315.png)

``分段比分页更容易实现信息的共享和保护``

![image-20220517113624908](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517113624908.png)

![image-20220517113757602](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517113757602.png)

==访问一个逻辑地址需要几次访存？==

![image-20220517113901262](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517113901262.png)

回顾

![image-20220517113914859](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517113914859.png)

可重入代码：是一种允许多个进程同时访问的代码，为了使各进程所执行的代码完全相同，故不允许任何进程对其进行任何修改。

页式：

两个进程通过两个页表共享一段内存空间。

![image-20220624182630300](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624182630300.png)

段式：

因为程序都是通过含义来分段的：这样程序就分成两段，段表只有两项

![image-20220624182806434](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624182806434.png)

![image-20220624182953239](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624182953239.png)

### 段页式管理(分配回收)

不可能先分页，再分段，因为分段是按照程序逻辑的。所以肯定是先分段

![image-20220624183051355](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624183051355.png)

![image-20220624183133806](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624183133806.png)

![image-20220624183236680](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220624183236680.png)

#### 分段和分页的优缺点分析

分页：不会产生外部碎片，但是不方便按照逻辑模块实现信息的共享和保护

分段：很方便按照逻辑模块实现信息的共享和保护，缺点有两个，一个是分配太大的连续空间不方便，另外段式管理会产生外部碎片。

那么外部碎片怎么来的呢？假设内存空间中有这些分段，这时候14MB的分段移出内存

![image-20220517114403367](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517114403367.png)

来了一个4MB字节的段，假设20MB也用完了

![image-20220517114759842](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517114759842.png)

14MB字节重新调入内存

![image-20220517114837725](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517114837725.png)

20MB又调入内存，就算内存空间有剩余，也调入不了内存空间，可以用紧凑技术，但是时间代价大

![image-20220517114931607](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517114931607.png)

#### 逻辑地址结构

逻辑地址由段号，页号，页内偏移量三部分构成，用户编程的时候只需要给出段号和段内地址，之后系统会自动的把段内地址拆分为页号和页内偏移量两个部分，因为用户只需要提供段号和段内地址两部分信息，因此段页式管理的地址结构是二维的。

段号是用户可见的，页号是系统管理的行为对用户不可见。	

![image-20220517165017082](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517165017082.png)

#### 段表、页表

一个进程对应一个段表，但是有可能对应多个页表

这里的段表和分段存储管理不一样的是，段表是由

段号，页表长度，页表存放地址三个部分组成。

页表是一样的，都是页号和页内偏移量（页面存放的内存块号）

![image-20220517165312243](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517165312243.png)

#### 地址变换

访问段表，访问页表，访问目标内存单元，三次访存

引入快表的话，用段号和页号作为查询快表的关键字，如果命中只需要==一次访存==。

![image-20220517165749552](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517165749552.png)

![image-20220517165827109](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517165827109.png)

### 虚拟内存(空间扩充)

![image-20220517170737799](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517170737799.png)

![image-20220517170748156](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517170748156.png)

#### 传统存储管理方式的缺点

传统存储管理指的是这些：

![image-20220517170848138](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517170848138.png)

传统存储管理存在一次性和驻留性的缺点：

作业必须一次性全部装入内存。

一旦装入内存，就会一直驻留在内存。

![image-20220517171041594](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517171041594.png)

#### 局部性原理

虚拟内存技术的提出是基于局部性原理的.

==时间局部性==：比如循环，指向了某条指令，这条指令很可能还会再执行。

如果这个数据被访问，不久后很可能还会被访问，比如这个i

==空间局部性==：比如数据，一旦程序访问了某个存储单元，不久之后，附近的存储单元也很有可能被访问。

比如访问了a[0],就很可能会访问旁边的a[1]。

![image-20220517172510636](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517172510636.png)

#### 虚拟内存的定义和特征

![image-20220517174011430](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517174011430.png)

####  如何实现虚拟内存技术

![image-20220517174155634](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517174155634.png)

![image-20220517174350681](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517174350681.png)

### 请求分页管理方式

![image-20220517174616358](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517174616358.png)

#### 页表机制

基本页表和请求分页的页表的区别

![image-20220517174917478](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517174917478.png)

#### 缺页中断机构

==第一种情况==:内存中有空闲块,直接为进程分配一个空闲块,将页面装入该块.并且修改页表中的相应页表项.

==第二种情况==:如果内存中没有空闲块，那么久用页面置换算法淘汰一个页面，假设淘汰了C号块，而且发现C号块在内存期间被修改过，则要将其写回外存。再讲要调入的内存的信息修改掉.

![image-20220517183210529](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517183210529.png)

![image-20220517183416095](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517183416095.png)

两个页面都没有调入内存

![image-20220517183612891](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517183612891.png)

#### 地址变换机构

和基本分页存储管理的区别:

![image-20220517184020141](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184020141.png)

拿着页号去快表中看看是否存在快表中，如果有就加上偏移量找到实际的物理地址执行相应指令即可
若找不到则先将页号和页表寄存器比较一下，看看是否越界
若没越界则去请求页表中，若页表中没有这个页面，则触发缺页中断，将进程塞到阻塞队列中
将页面从外内捞到内存中，注意，若内存没有空闲空间则还会通过页面置换算法移出某些页面，并将这些页面的修改信息写回外存对应的位置中
将页面加载到内存中，并加上偏移量找到对应指令并执行

![image-20220517184137055](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184137055.png)

![image-20220517184308374](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184308374.png)

![image-20220517184331132](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184331132.png)

### 页面分配算法

![image-20220517184418687](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184418687.png)

#### 最佳置换算法

为什么选择淘汰7号页面,因为在目前内存中的就是0,1,7,但是7的最后被访问到的,也就是说7是最长时间内不再被访问的.

`也就是说预测未来了属于是`

![image-20220517184641252](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184641252.png)

![image-20220517184814153](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184814153.png)

缺页不一定发生页面置换,还有可能是请求调页.

![image-20220517184837660](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517184837660.png)

==缺页率=缺页中断次数/访问页面次数=9/20==

``最佳置换算法是无法实现的``

![image-20220517185026895](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185026895.png)

#### 先进先出置换算法

![image-20220517185203781](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185203781.png)

注意每次都插入队尾

0号页面加进来之后,并不是插入3的位置,==而是插入队尾==

![image-20220517185253804](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185253804.png)

再来3

![image-20220517185308143](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185308143.png)

##### Belady异常

![image-20220517185405823](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185405823.png)

#### 最近最久未使用

性能最接近最佳置换算法的

从内存不够用的位置3开始,逆向往前找,找到在内存中最远出现的的一个内存块,说明很久没用到了.所以置换7

![image-20220517185537393](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185537393.png)

![image-20220517185717343](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185717343.png)

#### 时钟置换算法

从队头开始扫描,扫描过的访问位的1变成0,如果中途遇到0,就不往下扫描了,直接把6加入。

`过程`:假设此时访问6号页面。

从1开始扫描，(1,1)-->(3,1)-->(4,1)-->(2,1)-->(5,1)

扫描完成之后：(1,0)-->(3,0)-->(4,0)-->(2,0)-->(5,0)

再次扫描，发现（1，0）有0，就把6号页面载入。载入之后，访问位变成1. 扫描指针指向下一个页面

​              |

​              v

(6,1)-->(3,0)-->(4,0)-->(2,0)-->(5,0).

接下来访问3，4

(6,1)-->(3,1)-->(4,1)-->(2,0)-->(5,0).

再访问7

(6,1)-->(3,1)-->(4,1)-->(7,1)-->(5,0).

![image-20220517185858117](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517185858117.png)

扫描后

![image-20220517192432034](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517192432034.png)

访问到6,看上图,1号是0,从队头开始,1是队头,然后就把1替换

![image-20220517192618822](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517192618822.png)

接下来看上图,访问3和4,把0改成1

![image-20220517191254621](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517191254621.png)

注意,把0改成1的时候,并没有扫描,所以指针不变.现在7进来的时候才扫描,把3和4变成0

![image-20220517192728708](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517192728708.png)

最终是这样:扫描的指针到下一个位置,因为刚刚扫到2扫完了

![image-20220517192858031](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517192858031.png)

![image-20220626181157630](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626181157630.png)

#### 改进型的时钟置换算法

==第一轮==:从头开始,找(0,0),不修改任何标志位

==第二轮==:如果第一轮失败,从头开始,找(0,1),访问位置都设为0

==第三轮==:如果第二轮失败,从头开始,找(0,0),不修改任何标志位

==第四轮==:如果第三轮失败,从头开始,找(0,1)

![image-20220517193339745](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517193339745.png)

看一个四轮扫描的例子

第一轮:找00,不修改标志位

![image-20220517193837589](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517193837589.png)

第二轮找01,并且把访问位设为0,但是没有原本就是0,1的

![image-20220517193938885](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517193938885.png)

第三轮找00,不修改任何访问位

![image-20220517193938885](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517193938885.png)

第四轮找01,发现第一个就是

![image-20220517194056574](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517194056574.png)

> 第一轮:不修改任何标志位
>
> 找的是(0,0),找的是没访问，没修改的
>
> 第二轮：修改访问位，也就是第一位
>
> 找的是(0,1)，找的是没访问，但是修改了的
>
> 第三轮:不修改任何标志位
>
> 找的是(0,0),其实找的是10,因为左边的1被第二轮改过。
>
> 第四轮:
>
> 找的是(0,1),其实找的是11,因为左边的1被第二轮改过

#### 对比

![image-20220517193331145](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517193331145.png)

### 页面分配策略

![image-20220517194441108](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517194441108.png)

#### 驻留集

``请求分页存储管理系统中``给进程分配的==物理块的集合==.也就是页框的集合.

驻留集是请求分页管理中给进程分配的物理块大小的集合。
需要了解的是，若采用虚拟存储技术的系统中，驻留集的大小可以小于进程。
而对于驻留集大小分配也是一门学问，若驻留集分配过小，就可能造成频繁的缺页中断。
而驻留集分配过大的话，会有大量进程涌入请求执行，cpu需要给处理每个进程，进而造成僧多肉少的情况，从而导致并发度下降。
本来cpu和io是并行的,但是现在并行的几率少很多.

##### 三种分配方式

![image-20220517195111812](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517195111812.png)

什么是未锁定的?

![image-20220517195723696](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517195723696.png)

![image-20220517195559380](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517195559380.png)

#### 调入页面的时机

==预调页策略==

根据局部性原理，我们可以在调页面的时候将这个页面附近的页面也调入进程中，从而减少没必要的io次数，虽然这个预测成功率只有50%，但是我们也可以运用这种原理让程序员自行分配先调入的页面的部分。

==请求调页策略==

即缺哪个页面调哪个页面，io开销略大。

#### 何处调入页面

我们都知道外存中对换区的io速度比文件区块，所以当对换区有足够的空间时，发生缺页我们就在缺少的页面先调入对换区与内存进行交换。
若对换区空间不够，我们就将进程那些没有修改的页面直接从文件区与内存进行调入。
需要补充的时unix方式，他在加载进程时，全部都是从文件区调入，当页面换出外存时，先调回对换区，等待下次调入。

> 系统有足够的对换空间,每次都直接在内存和对换区之间进行

![image-20220517200045042](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517200045042.png)

> 缺少对换区空间

![image-20220517200147690](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517200147690.png)

> UNIX方式:

![image-20220517200255197](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517200255197.png)

#### 抖动

说白了就是一个页面刚刚被调入就被调出了，这种情况的原因也很简单，就是页面数目远远高于物理块页数。

![image-20220517200456089](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517200456089.png)

#### 工作集

对于抖动(颠簸)现象我们可以创建一个工作集来记录某段时间进程需要运行的页数然后记录到工作集中，物理块的分配就可以参考工作集大小，这样减少了抖动(颠簸)现象的发生.

![image-20220517200647448](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517200647448.png)

![image-20220517200758280](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517200758280.png)

## 文件管理

### 初识文件管理

![image-20220626215129086](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626215129086.png)

#### 文件属性

![image-20220626215336569](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626215336569.png)

#### 文件数据如何组织

![image-20220626215423107](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626215423107.png)

无结构文件：由一系列二进制或字符流组成

有结构文件：讨论是用顺序表存放还是索引表？

![image-20220626215459727](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626215459727.png)

#### 文件之间如何组织

![image-20220628150239847](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628150239847.png)

#### 操作系统应该提供什么功能

![image-20220628150510233](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628150510233.png)

![image-20220628151230933](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628151230933.png)

#### 文件如何存放在外存

![image-20220628151348469](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628151348469.png)

![image-20220628151431813](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628151431813.png)

![image-20220628151504131](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628151504131.png)

### 文件的逻辑结构



### 磁盘的结构

![image-20220626214839494](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626214839494.png)

#### 概念

##### 磁盘、磁道、扇区

![image-20220626213653758](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626213653758.png)

#### 如何在磁盘读写数据

如果我们想要读取橙色磁道的数据，首先磁头臂带着磁头移动。

![image-20220626213755527](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626213755527.png)

变成这样：

![image-20220626213924813](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626213924813.png)

这个地方我们只看见了一个盘面，实际上是由很多个盘面组成的

#### 盘面、柱面

盘片是什么：如图有四层，就是一个盘片，一个盘片可能有两个盘面，就是正反都能用。

磁头都是在同一个磁头臂的，只能共进退。

柱面是什么：同一个颜色的磁道。

柱面号是用来定位盘面的磁道的。

盘面号是用来选择到底是哪个盘面的磁道。

扇区号是用来选择是磁道的哪个扇区。

![image-20220626214133075](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626214133075.png)

#### 磁盘物理地址

#### 磁盘分类

##### 磁头是否可以移动

![image-20220626214729474](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626214729474.png)

##### 盘片是否能更换

![image-20220626214811715](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220626214811715.png)

### 磁盘调度算法

![image-20220628152310104](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628152310104.png)

#### 读写操作时间

##### 寻道时间

`首先启动磁头臂`：因为不启动磁头臂是不能移动的

`再移动磁头`:移动磁头用于找到磁道

`每个磁道都要花一部分时间`

![image-20220628152732567](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628152732567.png)

![image-20220628153206593](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628153206593.png)

##### 延迟时间

速度是r,平均转一圈就是1/r。

又因为找到目标扇区平均需要转半圈。所以再乘以1/2.

也就是1/(2r)。

现在的转速一般是5400转/分，或者7200转/分

![image-20220628153421170](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628153421170.png)

##### 传输时间

因为数据分布在一个磁道上，要读完的话要转一圈。转一圈的时间是1/r

读b/N个磁道。

![image-20220628162524807](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628162524807.png)

![image-20220628162734732](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628162734732.png)

#### 调度算法

##### FCFS

磁头初始位置是100号磁道。那么移动到最先来的55号磁道，要45，然后移动到48 要3.。。。

![image-20220628162908680](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628162908680.png)

##### SSTF

![image-20220628165410436](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628165410436.png)

##### SCAN

![image-20220628165708640](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628165708640.png)

##### Look调度

![image-20220628203316995](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628203316995.png)

##### C-SCAN算法

![image-20220628203538316](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628203538316.png)

##### C-Look算法

![image-20220628203652637](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628203652637.png)

![image-20220628203829613](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220628203829613.png)

## IO管理

### 概念及分类
