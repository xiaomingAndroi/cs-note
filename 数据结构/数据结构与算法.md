# 数据结构与算法

## 线性表

### 顺序表

![image-20220325092647499](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325092647499.png)

#### 静态分配

![image-20220325093014778](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325093014778.png)

![image-20220325093120938](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325093120938.png)

#### 动态分配

![image-20220325093253169](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325093253169.png)

##### 动态增加顺序表长度

> 动态分配有两个好处：一个是能够动态增加数组长度，一个是避免定义了但是不用的情况时候的空间浪费

![image-20220325093539483](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325093539483.png)

![image-20220325093750440](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325093750440.png)

> 代码实现：
>
> 可以用realloc，或者用malloc

```c++
bool increaseSize(ArrayList& arrayList,int size) {
	ElmentType *oldData = arrayList.data;//老数据
	int newSize = MAXSIZE + size;
	arrayList.data=new ElmentType[newSize];
	for (int i = 0; i < arrayList.length; i++)
	{
		arrayList.data[i]=oldData[i];
	}
	arrayList.maxSize = newSize;
	delete oldData;
	return true;
}
```

#### 回顾

![image-20220325093824881](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325093824881.png)

#### 初始化

```c++	
#include<iostream>
#define MAXSIZE 5
using namespace std;
typedef  int ElmentType;
typedef struct {
	ElmentType* data;
	int maxSize;
	int length;
}ArrayList;

bool initList(ArrayList &arrayList) {
	arrayList.data = new ElmentType[MAXSIZE];
	arrayList.length = 0;
	arrayList.maxSize = MAXSIZE;
	return true;
}
```

#### 增加操作

```c++
bool insertList(ArrayList& arrayList,ElmentType data) {
	int nowIndex,increase, maxSize;
		nowIndex = arrayList.length;
		maxSize = arrayList.maxSize;
		if ((nowIndex >maxSize-1))
		{
			cout << "输入要扩容多少？输入-1不扩容直接打印" << endl;
			cin >> increase;
			if (-1 == increase)
			{
				return false;
			}
			increaseSize(arrayList, increase);
			
			
		}
		cout << "nowIndex:" << nowIndex << endl;
		cout << "MAXSIZE:" << maxSize << endl;
		arrayList.data[nowIndex] = data;
		arrayList.length++;
	

	return true;
}
```

#### 删除操作

> 要删除的元素是第 index-1个，后面的用循环依次移动过来。
>
> 如果用i=index+1的话，就是第i个被第i+1个覆盖。

```c++
bool deleteByIndex(ArrayList& arrayList, ElmentType &data,int index) {
	// 1 2 3 4 5 
	// 0 1 2 3 4 
	data = arrayList.data[index - 1];
	for (int i = index-1; i < arrayList.length; i++)
	{
		arrayList.data[i] = arrayList.data[i+1];//第i个被第i+1个覆盖。
	}
	arrayList.length--;
	return true;
}
```

> 时间复杂度分析

![image-20220325132209335](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325132209335.png)



#### 插入操作

> i是最后一个元素，从最后一个元素开始，依次后移

```c++
bool insertByIndex(ArrayList& arrayList, ElmentType data, int index) {
	//1 2 3 4 5 
	for (int i = arrayList.length-1; i >=index-1; i--)
	{
		arrayList.data[i+1] = arrayList.data[i];//i是最后一个元素，
	}
	arrayList.data[index - 1] = data;
	arrayList.length++;
	return true;
}

```

> 时间复杂度：
>
> 假设新元素插入到任意位置的概率相同，1，2，3....和n+1的位置，n+1是表尾。所以概率都是1/n+1；
>
> 当插入第1个元素之前，也就是i=1的时候，循环n次。
>
> 当插入第2个元素之前，也就是i=2的时候，循环n-1次。
>
> ....
>
> 当插入第n+1个元素之前，也就是i=n+1的时候，循环0次。
>
> 平均循环次数就是 np+(n-1)p+(n-2)p+.....+1*p=(n+(n-1)+....1)p

![image-20220325214513801](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325214513801.png)

#### 查询操作

```c++
void printList(ArrayList& arrayList) {
	for (int i = 0; i < arrayList.length; i++)
	{
		cout << arrayList.data[i] << " ";
	}
}
```

#### 查找操作

> 按位查找	

![image-20220325132255443](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325132255443.png)

> 按值查找

![image-20220325132410260](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325132410260.png)

### 链表

![image-20220325132559020](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325132559020.png)

#### 单链表

##### 定义

![image-20220326154655726](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326154655726.png)

![image-20220326154751358](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326154751358.png)



```c++
#include<iostream>
using namespace std;
typedef int ElmentType;
typedef struct LNode{
	ElmentType data;
	LNode* next;
}LNode,*LinkList;
bool initList(LinkList &linkList) {
	linkList = new LNode;
	linkList->next = NULL;
	return true;
}
bool initList2(LinkList& linkList) {
	linkList = NULL;
	return true;
}
bool isEmpty(LinkList& linkList) {
	return linkList->next == NULL;
}
```

##### 插入

![image-20220326164139425](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326164139425.png)

![image-20220326164221789](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326164221789.png)

> 按位序插入

```c++
bool insertList(LinkList& linkList,ElmentType data) {
	LNode* newNode = new LNode;
	newNode->data = data;
	newNode->next = linkList->next;
	linkList->next = newNode;
	return true;
}
bool insertListByIndex(LinkList& linkList, ElmentType data,int index) {
	LNode* newNode = new LNode;
	LNode* movePoint = linkList;
	newNode->data = data;
	// . 0 1 2 3 4 5 
	//i代表的是现在指向第几个结点，如果i=1代表指向的是首元结点。
	for (int i = 0; i < index-1&&movePoint!=NULL; i++)
	{
		movePoint = linkList->next;
		
	}
	//也可以这样写。j代表的是现在指向的是第几个结点，如果j=0代表指向的是首节点，j=1代表指向的是首元结点。
	int j = 0;
	while (movePoint != NULL && j < index - 1)
	{
		movePoint = linkList->next;
		j++;
	}
	if (movePoint==NULL)
	{
		return false;
	}
	newNode->next = movePoint->next;
	movePoint->next = newNode;
	return true;
}
```

> 指定结点的后插操作

![image-20220326164429866](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326164429866.png)

###### 指定结点前插

> 指定结点的前插操作
>
> 由于单链表给定一个结点后，指定前插操作的实现不方便实现，除非给个头指针开始遍历。但是那样的话，时间复杂度就是N，
>
> 所以采取值覆盖的操作来进行，比如
>
> 1 3 4 5 6 ，要在3前面插入2，因为不知道结点3前驱结点的next域。
>
> 所以只能在3后面插入一个数据。但是把值覆盖掉。
>
> 2->next=3->next;
>
> 3->next=2;
>
> 3->data=2->data;
>
> 2->data=3->data;

```c++
bool insertPriorNode(LNode *p,ElmentType data) {
	LNode* newNode = new LNode;
	newNode->data = data;
	// 1 2 3 
	newNode->next = p->next;
	p->next = newNode;
	newNode->data = p->data;
	p->data = data;
	return true;
}
```



![image-20220326164625961](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326164625961.png)

##### 删除

> 按位序删除

![image-20220326174601367](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326174601367.png)

```c++
bool deleteNodeByIndex(LinkList& linkList,ElmentType data,int index) {
	int i = 0;//指向首节点
	LNode* moveNode = linkList;
	while (moveNode!=NULL&&i<index-1)
	{
		moveNode=moveNode->next;//找到要删除未知的前驱结点
		i++;
	}
	if (moveNode==NULL)
	{
		return false;
	}
	LNode* deleteNode=moveNode->next;
	moveNode->next=deleteNode->next;
	delete deleteNode;
	return true;
}
```

###### 指定结点删除

> 指定一个要删除的结点，如果不传入首节点，那就没法做。如果传入了首节点，可以循环找到要删除结点的前驱结点。但是时间复杂度比较高。我们还是能采取值覆盖的方式。比如 1 2 3 4 5 ，要删除4
>
> 可以把4->data=4->next->data;
>
> 4->next=4->next->next;
>
> 然后把4->next删除。
>
> 但是如果要删除的是5，5->next不存在，那就只能从头开始找了。

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326183147699.png"/>

~~~c++
bool deleteNode(LNode *deleteNode,ElmentType & data) {
	// 1 '2' 3 
	LNode* lastNode = deleteNode->next;
	deleteNode->data = lastNode->data;
	deleteNode->next = lastNode->next;
	delete lastNode;
	return true;
}
~~~

##### 查找

![image-20220326183500742](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326183500742.png)

![image-20220326183519615](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326183519615.png)

##### 头插法

链表的逆置

![image-20220326184122863](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326184122863.png)

```C++
bool headInsert(LinkList& linkList,ElmentType data) {
	linkList = new LNode;
	linkList->next = NULL;
	LNode* moveNode = linkList;
	while (data!=9999)
	{
		LNode* newNode = new LNode;
		newNode->data = data;
		newNode->next = linkList->next;
		linkList->next = newNode;
		cin >> data;
	}
	return true;
}
```

![image-20220502213304223](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502213304223.png)

![image-20220502213342211](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502213342211.png)

![image-20220502213811176](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502213811176.png)

##### 尾插法

> 这种做法时间复杂度太高了

![image-20220326205258797](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326205258797.png)

![image-20220326205030054](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326205030054.png)

> 设置一个尾指针，每次尾指针都指向最后一个元素，然后新增元素的时候，尾指针的next域都指向新增的元素，然后再让尾指针后移。

```C++
bool tailInsert(LinkList& linkList, ElmentType data) {
	linkList = new LNode;
	//linkList = NULL;
	LNode* tail = linkList;
	while (data!=NULL)
	{
		LNode* newNode = new LNode;
		newNode->data = data;
		tail->next = newNode;
		tail = newNode;
		cin >> data;
	}
	tail->next = NULL;
}
```

![image-20220502214031743](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502214031743.png)

tail->next=newNode

![image-20220502214124378](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502214124378.png)

tail=newNode

![image-20220502214210047](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220502214210047.png)

#### 双链表

##### 定义

![image-20220326205606543](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326205606543.png)

```c++
#include<iostream>
using namespace std;
typedef struct student
{
	int sno;
	char name[10];
}ElementType;

typedef struct DNode {
	ElementType data;
	DNode* prior, *next;
}DNode, *DLinkList;
int main() {
	DLinkList dLinkList;
	initDLinkList(dLinkList);
	return 0;
}

bool initDLinkList(DLinkList &dLinkList) {
	dLinkList = new DNode;
	dLinkList->next = NULL;
	dLinkList->prior = NULL;
	return	true;
}

bool isEmpty(DLinkList linkList) {
	if (linkList->next==NULL)
	{
		return true;
	}
	return false;
}
```

##### 插入

![image-20220326205914237](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326205914237.png)

> 实现插入操作的话，比如在A和B中间插入C，
>
> A的next域要指向C，C的prior域要指向A。B的next不变，prior域名要指向C。
>
> 
>
> A->next=C;
>
> C->prior=A;
>
> C->next=A->next;
>
> A->next->prior=C;

```c++
//在p结点之后插入s结点
bool insertList(DNode*p,DNode *s) {
	// p    v --->p s v 
	if (p==NULL||s==NULL)
	{
		return false;
	}
	s->prior = p;
	s->next = p->next;
	if (p->next!=NULL)
	{
		p->next->prior = s;
	}
	p->next = s;
	return true;
}
```

##### 删除

> 删除操作，能快速找到前驱结点
>
> A B C ，如果要删除B的话
>
> B->next->prior=A;
>
> A->next=B->next;

![image-20220326212537828](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326212537828.png)

```c++
//这个删除的是p的后继结点
bool deleteNode(DNode *p) {
	if (p==NULL)
	{
		return false;
	}
	DNode* q = p->next;
	if (q==NULL)
	{
		return false;
	}
	p->next = q->next;
	if (q->next!=NULL)
	{
		q->next->prior = p;
	}
	
	delete(q);
}
```

##### 释放

![image-20220326212642366](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326212642366.png)

##### 遍历

![image-20220326212746636](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326212746636.png)

```c++
bool showList(DLinkList linkList,ElementType type) {
	DNode * node = linkList->next;
	while (node->next!=NULL)
	{
		type=linkList->data;
		cout << type.name << endl;
		cout << type.sno << endl;
	}
}
```



#### 循环链表

> 循环单链表应用场景：
>
> 需要对表头或者表尾进行操作的话，使用循环单链表

![image-20220326213141203](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326213141203.png)

>  循环双链表应用场景：



![image-20220326213255470](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326213255470.png)

##### 定义

![image-20220326213333495](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326213333495.png)

> 双链表和循环双链表插入的区别：

![image-20220326213438043](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326213438043.png)

> 双链表和循环双链表的删除的区别：

![image-20220326213734273](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326213734273.png)

#### 静态链表

![image-20220326214049503](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326214049503.png)

![image-20220326214330280](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326214330280.png)

##### 初始化

![image-20220326214727063](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220326214727063.png)

![image-20220327184001301](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220327184001301.png)

#### 多项式相加

> 定义一个结构体，输入指数和系数。
>
> coefficient---系数
>
> exponent---指数
>
> 先建立一个链表，定义一个头指针pre，一个首元结点的指针prev。如果要插入一个结点，pre和prev依次后移。
>
> 当发现prev->data大于当前的。就在pre和prev中间插入一个结点。
>
> 如下为创建有序结点：

![image-20220329195925330](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329195925330.png)

![image-20220329195941997](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329195941997.png)

![image-20220329195959934](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329195959934.png)

> 第一种情况：
>
> 如果指数一样，且相加等于0。
>
> 设置一个deleteNode，指向p1,p1往后移。再指向p2,p2往后移。

![image-20220329211646717](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329211646717.png)

移动后的情况是这样的：

![image-20220329211828324](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329211828324.png)

> 如果指数一样，且相加不等于0
>
> 首先让linkList3的next域，把线先补上，连接起来。

![image-20220329212050176](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212050176.png)

再用deleteNode把p2删除掉。P2指向下一个结点,LinkList3一个也指向x^7次方。

![image-20220329212106407](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212106407.png)

> p1比p2小, x^7<x^8。p1后移到x^10.

![image-20220329212416490](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212416490.png)

linkList3的next域名直接将p2连接起来。

![image-20220329212642750](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212642750.png)

然后linkList3移动到p2的位置。p2后移。

![image-20220329212725402](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212725402.png)

> 此时p1的x^10比p2的x^11小，p3的next域将p1连接起来，然后指向p1。p1移动到null。

![image-20220329212756578](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212756578.png)

![image-20220329212836426](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212836426.png)

> 最后linkList3的next域，将最后一个结点连接起来。

```c++

    linkList3->next = p1 ? p1 : p2; 

```



![image-20220329212941696](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329212941696.png)



## 栈和队列

### 栈

#### 定义

> 栈是只允许在一端进行插入和删除操作的线性表

![image-20220317204553940](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317204553940.png)



![image-20220317211153804](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317211153804.png)

后进先出，LIFO

![image-20220317211246571](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317211246571.png)

#### 基本操作

![image-20220317211348157](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317211348157.png)

#### 常考题型

![image-20220317211617567](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master//image-20220317211617567.png)

#### 顺序栈第一种

第一种写法是根据王道考研中的定义方法来的，

这种方法没有使用指向数据元素（ElementType）指针的方式，而是采用了定义一个int 类型的top 变量作为栈顶指针，

结构体中有一个ElementType 数组，初始化将其实例化一个MAXSIZE大小。

初始化栈顶指针的时候，int top =-1即可。

> 其实整个栈就是一个结构体，结构体包含一个MAXSIZE大小的数组和一个int类型的top变量。

> 进栈：SqStack.data[++SqStack.top]=x;



##### 初始化判空

```c++
#include<iostream>
#define MAXSIZE 10
struct ElemType {
	int sno;
};
typedef struct {
	ElemType data[MAXSIZE];
	int top;//栈顶指针
}SqStack;

int main() {
	SqStack sqStack;//申明一个栈的存储空间.
	return 0;
}
void initStack(SqStack &sqStack) {
   // sqStack = new SqStack[MAXSIZE];  经典的错误，标准的零分。
	sqStack.top = -1;
}

bool stackEmpty(SqStack sqStack) {
	if (sqStack.top == -1)  return true;
	else return false;
}
```



![image-20220317212454868](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317212454868.png)

##### 进栈操作

```c++	
bool push(SqStack& sqStack,ElemType elemType) {
	if (sqStack.top==MAXSIZE-1)
	{
		return false;
	}
	//sqStack.top++;
	//sqStack.data[sqStack.top] = elemType;//因为top本来在-1
	sqStack.data[++sqStack.top];
	return true;
}
```

![image-20220317213342531](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317213342531.png)

#####  出栈操作

```c++
bool pop(SqStack& sqStack, ElemType& elemType) {
	if (stackEmpty(sqStack))
	{
		return false;
	}
	else
	{	
		elemType=sqStack.data[sqStack.top--];	
		return true;
	}
}
```

![image-20220317213752365](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317213752365.png)

##### 读栈顶元素

```c++
bool getTop(SqStack& sqStack, ElemType& elemType) {
	if (sqStack.top == -1)
	{
		return false;
	}
	elemType = sqStack.data[sqStack.top];
	return true;
}
```

![image-20220317214305544](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317214305544.png)

##### 两种不同初始化栈的方式

![image-20220317214413675](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317214413675.png)

##### 共享栈

![image-20220317215038950](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220317215038950.png)

#### 顺序栈第二种

##### 定义

在结构体中定义两个指针*  base和top，一个stackSize变量，表明栈内元素个数。

```c++
#include <iostream>
using namespace std;
#define MAXSIZE 100
struct SElemType
{
	char sno;
};
typedef struct {
	SElemType* base;
	SElemType* top;
	int stackSize;
}SqStack;
```

##### 初始化

初始化的时候，让base和top都指向一块数组空间。

sqStack.base是一个类型的指针，但是指向的是一大块存储空间，能行吗？不行，其实只指向一小块。

```c++	
int initStack(SqStack &sqStack) {
	sqStack.base=new SElemType[MAXSIZE];
	if (!sqStack.base)
	{
		return -1;
	}
	sqStack.top = sqStack.base;
	sqStack.stackSize = MAXSIZE;
	return 1;
}
```

##### 进栈

```java
int push(SqStack& sqStack, SElemType type) {
	
	if (sqStack.base - sqStack.top == sqStack.stackSize)
	{
		return 0;
	}
	*sqStack.top++ = type;
	return 1;
}
```

##### 出栈

```c++
int pop(SqStack& sqStack, SElemType& type) {
	if (sqStack.top == sqStack.base)
	{
		return -1;
	}
	type = *--sqStack.top;
	cout << type.sno;
	
}
```

##### 判空

````c++
bool stackEmpty(SqStack sqStack) {
	if (sqStack.base==sqStack.top)
	{
		return true;
	}
	return false;
}
````

##### 栈长度

```c++
int stackLength(SqStack sqStack) {
	return sqStack.top - sqStack.base;
}
```

##### 清空和销毁

```c++
int clearStack(SqStack &sqStack) {
	if (sqStack.base)
	{
		sqStack.top = sqStack.base;
	}
	return 1;
}

int destroyStack(SqStack &sqStack) {
	if (sqStack.base)
	{
		delete[] sqStack.base;
		sqStack.stackSize = 0;
		sqStack.base = sqStack.top=NULL;
	}
	return 1;
}
```



#### 链栈

![image-20220318104737418](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318104737418.png)

> 进栈操作其实就是链表的头插法，首先让新生成的结点，指向原本首结点的下一项，然后再让首结点的下一项，指向自己
>
> 出栈操作其实就是每次都删除链表的头一项，也就是首元结点。让首节点的指向指到新的首元结点，再删除老的首元结点即可。

```c++	
#include<iostream>
using namespace std;
struct ElementType {
	int sno=0;
};
typedef struct LinkNode {
	ElementType data;
	LinkNode* next;
}*LinkStack;



bool initStack(LinkStack &linkStack) {
	linkStack = new LinkNode;
	linkStack->next = NULL;
	return true;
}
//在头部进行
bool push(LinkStack& linkStack,ElementType elememt) {
	cout << "输入";
	cin >> elememt.sno;
	while (elememt.sno!=9999)
	{
		LinkNode *newNode = new LinkNode;
		newNode->data = elememt;
		newNode->next = linkStack->next;
		linkStack->next = newNode;
		cin >> elememt.sno;
	}
	return true;
}
bool pop(LinkStack& linkStack, ElementType& elementType) {
	LinkNode* linkNode = linkStack;
	while (linkStack->next != NULL)
	{
		linkNode = linkStack->next;
		elementType = linkNode->data;
		cout << "-----------------------";
		cout << elementType.sno << endl;;
		linkStack->next = linkNode->next;
		delete linkNode;
	}
	return true;
}

bool findTop(LinkStack& linkStack, ElementType& elementType) {
	if (linkStack->next!=NULL)
	{
		elementType = linkStack->next->data;
		return true;
	}
	return false;
}
bool isEmpty(LinkStack& linkStack){
	if (linkStack->next==NULL)
	{
		return true;
	}
	return false;
}

int main() {
	LinkStack linkStack;
	ElementType elementType;
	initStack(linkStack);
	push(linkStack, elementType);
	findTop(linkStack, elementType);
	cout << "第一个元素是：" << elementType.sno << endl;
	pop(linkStack, elementType);
}
```

#### 表达式求值理论

![image-20220323164327175](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323164327175.png)

> 如何不用界限符就无歧义的表达运算顺序？

![image-20220323164421942](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323164421942.png)

##### eg1

> a+b-c转为后缀表达式：
>
> a+b先算，----->ab+
>
> ab+整体-c------>ab+c-
>
> a+b-c转为前缀表达式：
>
> a+b先算----->+ab
>
> a+b整体-c---->-+abc

![image-20220323164818294](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323164818294.png)

##### eg2

> 先算1+1
>
> 11+
>
> 再算7-(1+1)
>
> 711+ -
>
> 再算15/7-(1+1)
>
> 15711+ -/
>
> 再算15/7-(1+1)*3
>
> 把 15/7-(1+1)看成整体， 15 7 11  + -/  3*
>
> 再减（2+（1+1））
>
> 先算1+1
>
> 11 +
>
> -（2+（1+1））
>
> 2 11++ -
>
> 最后得到：15 7 11  + -/  3* 2 11++- 

![image-20220323165052000](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323165052000.png)

![image-20220325211814545](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220325211814545.png)

##### eg3

> 先把（C-D）看成整体
>
> CD- 
>
> B*(C-D)
>
> BCD-*
>
> ABCD-*+
>
> EF/
>
> EF/-
>
> ABCD-*+EF/-

![image-20220323170225884](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323170225884.png)

> 机器是左边这种表达式

![image-20220323170715931](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323170715931.png)

##### eg4

> A+B看成一个整体：
>
> ---->AB+
>
> -C*D看成一个整体：
>
> --->CD*
>
> CD*E/
>
> AB+CD*E/-F+
>
> 

![image-20220323170805861](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323170805861.png)

##### 后缀表达式计算过程---算法实现思想

> 算法思想
>
> 从左往右扫描，遇到一个运算符，就让运算符前面两个操作数执行对应运算。
>
> 最后出现的操作数先被运算。和栈的特性吻合了，后进先出。

![image-20220323172058532](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323172058532.png)

![image-20220323172131288](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323172131288.png)

> 算法思想：
>
> 从左往右扫描，扫描到操作数就压入栈中、扫描到运算符就弹出两个栈顶元素，和运算符执行运算，运算结果压入栈中。

![image-20220323174806452](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323174806452.png)

> 先出栈的是右边的操作数。AB+ ,在栈中从下往上看是，BA,先出来B，在做减法和除法的时候小心出错！！！

![image-20220323180107552](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180107552.png)

> 如果合法，栈中只会有一个元素

![image-20220323180326596](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180326596.png)

> 结果是5

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180450551.png"/>

##### 后缀表达式转中缀表达式

![image-20220323181107950](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323181107950.png)

##### 中缀表达式转前缀表达式

![image-20220323180749598](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180749598.png)

![image-20220323180827852](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180827852.png)

##### 前缀表达式计算算法思想

![image-20220323180923093](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180923093.png)

##### 总结

![image-20220323180943352](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323180943352.png)

#### 实例1：括号匹配问题

> 思想：
>
> 扫描到左括号就入栈，扫描到右括号就出栈。每次出现一个右括号就要消耗一个左括号。

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319182730076.png"/>



![image-20220319182823206](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319182823206.png)

![image-20220319182922618](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319182922618.png)

![image-20220319182958897](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319182958897.png)



![image-20220319183214384](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319183214384.png)

##### 代码实现

> 使用顺序栈解决括号匹配问题。
>
> 思想：
>
> 输入一个字符串，设置一个循环遍历字符串：
>
> 遇到左括号（ { [ 就直接入栈。
>
> 如果不是左括号
>
> 1.检查栈是否为空，如果是空，return false。因为栈里面都空了，肯定没办法去匹配。
>
> 2.如果栈不为空，那就弹出一个元素，检查弹出来的元素，是否和当前的右括号匹配。如果不匹配，return false。
>
> 3.当字符串全部遍历完了之后，返回栈是否为空，如果是空，说明匹配成功

```c++
bool match(SqStack sqStack,string datas) {
	ElementType newType;
	ElementType topElem;
	for (int i = 0; i < datas.length(); i++)
	{
		newType = datas[i];
		if ((newType == '(') || (newType == '{') || (newType == '['))
		{
			push(sqStack, newType);
		}
		else
		{
			if (isEmpty(sqStack))
			{
				return false;
			}
			pop(sqStack, topElem);
			
			if (newType ==')'&&topElem!='(')
			{
				return false;
			}
			if (newType == '}' && topElem != '{')
			{
				return false;
			}
			if (newType == ']' && topElem != '[')
			{
				return false;
			}
		}

	}

	return isEmpty(sqStack);
	
}
```

![image-20220323122556751](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323122556751.png)

#### 实例2：逆波兰表达式

![image-20220319193757965](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319193757965.png)

![image-20220323181329694](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323181329694.png)

##### 代码实现

>算法思想：
>
>因为不知道输入的中缀表达式多长,此时采用链栈的方式。
>
>如果遇到非运算符或括号，直接输出。不用进栈。
>
>如果遇到运算符和左括号，就进栈。
>
>栈中的表达式只能优先级低的在优先级高的下面，比如乘号在底下，这时候出现加号，加号出栈。
>
>如果检测到右括号，就需要把左括号中间的，包括左括号，全部出栈，但是左括号不输出。

比如a*(b+c)/d+e，步骤是：

> a直接输出
>
> ------a
>
> x入栈，左括号入栈，此时栈中，有x，（
>
> b直接输出
>
> -----ab
>
> +入栈，此时栈中，有x，（，+
>
> c直接输出
>
> ----abc
>
> 遇到 ) ，一直出栈，找到左括号为止。 ( ,+出栈。 现在输出  abc+,栈中有x.
>
> ----abc+
>
> /出现时，发现/（当前元素）优先级不大于x（栈顶元素）,栈顶元素x出栈，当前元素入栈，此时输出
>
> ------  abc+*
>
> d输出，
>
> ------  abc+*d
>
> +出现时，发现+（当前元素）优先级不大于/（栈顶元素)，栈顶元素出栈，当前元素入栈
>
> ------  abc+*d/
>
> e输出
>
> ------  abc+*d/e
>
> 循环完字符串后，再把栈清空
>
> ------  abc+*d/e

```c++
#include<iostream>
#include<ctype.h>
using namespace std;
typedef struct OPTR {
	char data;
	OPTR* next;
}*LinkOptr;
bool isEmpty(LinkOptr& linkOptr) {
	return linkOptr->next == NULL;
}
bool getTop(LinkOptr& linkOptr, char& data) {
	if (isEmpty(linkOptr))
	{
		return false;
	}
	data = linkOptr->next->data;
	return true;
}
bool initStack(LinkOptr& linkOptr) {
	linkOptr = new OPTR;
	linkOptr->next = NULL;
	return true;
}
bool pop(LinkOptr& linkOptr, char& data) {
	if (isEmpty(linkOptr))
	{
		return false;
	}
	OPTR* linkNode = linkOptr;
	linkNode = linkOptr->next;
	data = linkNode->data;
	linkOptr->next = linkNode->next;
	delete linkNode;
	return true;
}
bool push(LinkOptr& linkOptr, char data) {
	LinkOptr newNode = new OPTR;
	newNode->data = data;
	newNode->next = linkOptr->next;
	linkOptr->next = newNode;
	return true;
}
void expression(LinkOptr& linkOptr, string datas)
{
	char ch;
	int len = datas.length();
	for (int i = 0; i < len; i++)
	{
		if (isalpha(datas[i])) {
			cout << datas[i];
			continue;
		}
		 if ( datas[i] == '(')
		{
			 push(linkOptr, datas[i]);
			 continue;
		}
		 if (datas[i] == ')')
		{
			while (1) {
				if(!pop(linkOptr, ch)) return;
				if (ch == '(')  break;
				cout << ch;	
			}
			continue;
		}
		 if ((datas[i]=='+') ||(datas[i]=='-') || (datas[i] == '*') || (datas[i] == '/'))
		 {
			 while (1) {
				 if (!getTop(linkOptr, ch))  break;//如果为空，break掉，while循环外进栈。
				 if (ch == '(') break;//如果栈顶是左括号，break掉，while循环外进栈。
				 int pri1=0,pri2=0;//pri1--当前的优先级。pri2--栈顶元素的优先级
				 if ((datas[i] == '+') || (datas[i] == '-')) pri1 = 1;
				 if ((datas[i] == '*') || (datas[i] == '/')) pri1 = 2;
				 if ((ch == '+') || (ch == '-')) pri2 = 1;
				 if ((ch == '*') || (ch == '/')) pri2 = 2;
				 if (pri1 > pri2) break;//如果当前的优先级，大于栈顶的优先级。当前元素入栈。
				 pop(linkOptr, ch);//如果当前优先级小于等于栈顶优先级，栈顶元素出栈。
				 cout << ch;
				 continue;
			 }
			 push(linkOptr, datas[i]);
			 continue;
		 }
	}

	while (pop(linkOptr, ch))
	{
		cout << ch;
	}
}

int main() {
	LinkOptr linkOptr;
	initStack(linkOptr);
	string datas;
	cin >> datas;
	expression(linkOptr, datas);
}


```

#### 实例3：表达式求值

![image-20220323164200477](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323164200477.png)

![image-20220323181607997](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220323181607997.png)

> 算法思想：
>
> 输入一个中缀表达式，把中缀表达式转化为后缀表达式，然后再把后缀表达式，从左边往右依次扫描。
>
> 扫描到一个运算符，弹出两个栈顶元素与运算符进行计算。
>
> 到最后，栈里面应该只剩下一个元素才算正确，否则是不正确的。

整个代码如下:

```c++
#include<iostream>
#include<ctype.h>
#include<cstring>
using namespace std;
typedef struct OPTR {
	char data;
	OPTR* next;
}*LinkOptr;
typedef struct OPND {
	int data;
	OPND* next;
}*LinkOpnd;
bool isEmpty(LinkOptr& linkOptr) {
	return linkOptr->next == NULL;
}
bool getTop(LinkOptr& linkOptr, char& data) {
	if (isEmpty(linkOptr))
	{
		return false;
	}
	data = linkOptr->next->data;
	return true;
}
bool initStack(LinkOptr& linkOptr) {
	linkOptr = new OPTR;
	linkOptr->next = NULL;
	return true;
}
bool pop(LinkOptr& linkOptr, char& data) {
	if (isEmpty(linkOptr))
	{
		return false;
	}
	OPTR* linkNode = linkOptr->next;
	data = linkNode->data;
	linkOptr->next = linkNode->next;
	delete linkNode;
	return true;
}
bool push(LinkOptr& linkOptr, char data) {
	LinkOptr newNode = new OPTR;
	newNode->data = data;
	newNode->next = linkOptr->next;
	linkOptr->next = newNode;
	return true;
}
bool isEmpty2(LinkOpnd& linkOpnd) {
	return  linkOpnd->next == NULL;
}
bool getTop2(LinkOpnd& linkOpnd, int& data) {
	if (isEmpty)
	{
		return false;
	}
	data = linkOpnd->next->data;
	return true;
}
bool initStack2(LinkOpnd& linkOpnd) {
	linkOpnd = new OPND;
	if (!linkOpnd) return false;
	linkOpnd->next = NULL;
	return true;
}
bool push2(LinkOpnd& linkOpnd, int data) {
	OPND * newNode = new OPND;
	if (!newNode)return false;
	newNode->data = data;
	newNode->next = linkOpnd->next;
	linkOpnd->next = newNode;
	return true;
}
bool pop2(LinkOpnd& linkOpnd, int& data) {
	if (isEmpty2(linkOpnd)) return false;
	OPND * node=linkOpnd->next;
	data = node->data;
	linkOpnd->next=node->next;
	delete node;
	return true;
}
string expression(LinkOptr& linkOptr, string datas)
{
	char ch;
	string result;
	int len = datas.length();
	for (int i = 0; i < len; i++)
	{
		//如果一个字符被 isalpha() 或者 isdigit() 检测后返回“真”，
		//那么它被 isalnum() 检测后也一定会返回“真”。
		if (isalnum(datas[i])) {
			//cout << datas[i];
			result += datas[i];
			continue;
		}
		if (datas[i] == '(')
		{
			push(linkOptr, datas[i]);
			continue;
		}
		if (datas[i] == ')')
		{
			while (1) {
				if (!pop(linkOptr, ch)) return result;
				if (ch == '(')  break;
				//cout << ch;	
				result += ch;
			}
			continue;
		}
		if ((datas[i] == '+') || (datas[i] == '-') || (datas[i] == '*') || (datas[i] == '/'))
		{
			while (1) {
				if (!getTop(linkOptr, ch))  break;//如果为空，break掉，while循环外进栈。
				if (ch == '(') break;//如果栈顶是左括号，break掉，while循环外进栈。
				int pri1 = 0, pri2 = 0;//pri1--当前的优先级。pri2--栈顶元素的优先级
				if ((datas[i] == '+') || (datas[i] == '-')) pri1 = 1;
				if ((datas[i] == '*') || (datas[i] == '/')) pri1 = 2;
				if ((ch == '+') || (ch == '-')) pri2 = 1;
				if ((ch == '*') || (ch == '/')) pri2 = 2;
				if (pri1 > pri2) break;//如果当前的优先级，大于栈顶的优先级。当前元素入栈。
				pop(linkOptr, ch);//如果当前优先级小于等于栈顶优先级，栈顶元素出栈。
			   // cout << ch;
				result += ch;
				continue;
			}
			push(linkOptr, datas[i]);
			continue;
		}
	}

	while (pop(linkOptr, ch))
	{
		//cout << ch;
		result += ch;
	}
	return result;
}

int calculate(LinkOpnd& linkOpnd,string expression) {
	int length = expression.length();
	int data1=0,data2=0,data3=0;
	for (int i = 0; i < length; i++)
	{
		
		int nowData = expression[i];
		if (isalnum(nowData))//是数字就全部入栈
		{
			push2(linkOpnd,nowData-48);
		}
		else
		{
			 pop2(linkOpnd, data2);
			 pop2(linkOpnd, data1);
			switch (nowData)
			{
			case '+':
				data3 = data2 + data1;
				cout << data2 << "+" << data1 << endl;
				break;				
			case '-':				
				data3 = data1 - data2;
				cout << data1 << "-" << data2 << endl;

				break;				
			case '*':				
				data3 = data2 * data1;
				cout << data2 << "*" << data1 << endl;

				break;				
			case '/':				
				data3 = data1 / data2;
				cout << data1 << "/" << data2 << endl;

				break;
			default:
				break;
			}
			push2(linkOpnd, data3);
			
		}
	}
	pop2(linkOpnd, data3);
	if (isEmpty2(linkOpnd))
	{
		return data3;
	}
	else
	{
		cout << "栈出错" << endl;
		return 0;
	}
	
}
int main() {
	LinkOptr linkOptr;
	LinkOpnd linkOpnd;
	initStack(linkOptr);
	initStack2(linkOpnd);
	string datas;
	cin >> datas;
	datas = expression(linkOptr, datas);
	cout << datas << endl;
	cout << calculate(linkOpnd, datas) << endl;

}


```

#### 栈在递归中的应用

> 调用过程是怎么样的呢？
>
> 把函数应该执行的位置和参数，压入栈中
>
> 比如fun1,
>
> 把fun1的形参压入栈中，还有fun1()方法的下一行代码，也就是下一次应该执行的位置。
>
> 以及fun1函数的局部变量也压入栈中

![image-20220329111514951](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220329111514951.png)

##### 递归

![image-20220331212211852](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331212211852.png)

![image-20220331212855164](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331212855164.png)

![image-20220331212905927](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331212905927.png)

![image-20220331213117150](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331213117150.png)

在归并排序中：

如果有4个数据：

![image-20220418195042732](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418195042732.png)

> 执行MergeSort(0,3),会执行MergeSort（0，1）,执行MergeSort(0,1)会执行MergeSort(0,0);执行MergeSort(0,0)会返回到MergeSort(0,1),让代码执行下一行。

```java
//0 3 
public static void mergeSort(int[] arr,int low,int high,int depth){
        System.out.print(repeatCharacters('-',depth*2));
        System.out.println("Deal with ["+low+","+high+"]");

            if (low<high){
                int mid=(low+high)//mid=(0+3)/2=1
                mergeSort(arr,low,mid,depth+1);//--->(0,1)
                mergeSort(arr,mid+1,high,depth+1);//(2,3)
                merge(arr,low,mid,high);
            }
    }
```

![image-20220418195115202](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418195115202.png)

### 队列

> 栈：只允许在一端进行插入和删除操作的线性表
>
> 队列：只允许在一端进行插入，在另一端进行	删除的线性表

#### 队列的定义

![image-20220318160935755](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318160935755.png)

![image-20220318161025465](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318161025465.png)

#### 队列的基本操作

选择题比较喜欢考，队列判空

![image-20220318161109445](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318161109445.png)

![image-20220318161143338](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318161143338.png)

#### 顺序队列

如何判断队列已满？是rear==MAXSIZE 吗？答：不是的。

每次出队的时候，front会上移；本来队列满的时候是这样的：

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318164347613.png" alt="image-20220318164347613" style="zoom: 50%;" />

后来就是这样的：但是这时候，其实队列并没有达到饱和的状态。

![image-20220318163157876](C:/Users/CAP/AppData/Roaming/Typora/typora-user-images/image-20220318163157876.png)

如何解决这样的问题？怎么让rear指针重新指回到第一个元素呢？其实很简单。把队尾指针+1取模最大长度，也就是(q.rear+1)%MAXSIZE.比如现在rear在a[9], 所以（9+1）%10=0.rear指针就会移动到第一个元素上去。

![image-20220318164849612](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318164849612.png)

如何判断队满？

分析几种情况：

1) 如果不出队，一直入队，那么队头元素front一直在data[0],入队的时候

   ```c++
   if((q.rear+1)%10==q.front){
       return false;
   }
   q.data[q.rear]=x;//q.data[0]=x;
   q.rear=(q.rear+1)%10;//(0+1)/10;=1
   ```

   相当于每次rear都在有元素的元素上面一个，到rear=8的时候，存放到data[8],

   q.rear=(8+1)%10=9;

   下次存到data[9];代表已经存满。这时候如果还想插入，(9+1)%10==q.front,则不满足；

   此时会空一个data[9]的位置。

2) 如果会出队。比如此时rear指针到了data[9]，但是出队出了三个，front指向第四个元素data[3],这时候通过取模预算，rear会到第一个元素，data[0],再添加一个，取模是1，此时rear指向第二个元素data[1],再添加一个元素是data[2],取模是2，再要添加的时候，发现if条件不满足了，直接return flase;，此时总会有一个data[2]装不满。

![image-20220318172226775](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318172226775.png)

![image-20220318165003429](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318165003429.png)

##### 初始化

```c++
#include<iostream>
#define MAXSIZE 10
struct ElementType {
	int sno;
};
typedef struct {
	ElementType data[MAXSIZE];
	int front;//头指针
	int rear;//尾指针
}SqQueue;

void initQue(SqQueue &q) {
	q.front = q.rear = 0;
}
```

##### 判空

```c++
bool isEmpty(SqQueue q) {
	return q.front == q.rear;
}
```

##### 入队

```c++	
bool enQuene(SqQueue &q,ElementType e){
	if ((q.rear+1)%MAXSIZE==q.front)
	{
		return false;
	}
	q.data[q.rear] = e;
	q.rear = (q.rear + 1) % MAXSIZE;
}
```

##### 出队

![image-20220318205731171](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318205731171.png)

和入队的分析一样。入队有两种情况，一种是只入队，一种是一边入队一边出队。

如果只出队的话，front从0--1~9。如果front和rear指向同一个位置的话，说明队空。q.front=q.rear;



如果会入队。。。。



<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318164347613.png" alt="image-20220318164347613" style="zoom: 50%;" />

```c++	
bool deQuene(SqQueue &q,ElementType &e){
	if (isEmpty(q))
	{
		return false;
	}
	e = q.data[q.front];
	q.front = (q.front + 1) % MAXSIZE;
}
```

##### 查询头元素

```c++
bool getHead(SqQueue& q, ElementType& e) {
	if (isEmpty(q))
	{
		return false;
	}
	e = q.data[q.front];
	return true;
}

```

##### 判断队列空/满

###### 计算队列个数

###### 方法1

![image-20220318212216013](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212216013.png)



![image-20220318212226155](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212226155.png)

###### 方法2

![image-20220318212246419](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212246419.png)

![image-20220318212307929](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212307929.png)

###### 方法3

![image-20220318212342232](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212342232.png)

![image-20220318212546153](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212546153.png)

![image-20220318212712229](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212712229.png)

![image-20220318212720561](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220318212720561.png)

#### 链式队列

##### 带头结点初始化

![image-20220319120618750](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319120618750.png)

![image-20220319112910796](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319112910796.png)

```c++	
#include<iostream>
struct ElementType {
	int sno;
};
typedef struct QNode {
	ElementType data;
	QNode* next;
}QNode,*QNodeptr;

typedef struct {
	QNodeptr front;//队头指针
	QNodeptr rear;//队尾指针
}LinkQueue;

bool initQueue(LinkQueue &q) {
	q.front = q.rear = new QNode;
	q.front = NULL;

}
bool isEmpty(LinkQueue q) {
	return q.front == q.rear;
}
```

##### 不带头结点初始化

![image-20220319113128359](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319113128359.png)

```C++
bool initQueue2(LinkQueue &q) {
	q.front =q.rear= NULL;
}
bool isEmpty2(LinkQueue& q) {
	return q.front == NULL;
}
```

##### 入队（带头结点）

![image-20220319121349779](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319121349779.png)

![image-20220319123056335](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319123056335.png)

```c++
bool enQueue(LinkQueue & q,ElementType type){
	QNodeptr p= new QNode;//新节点
	p->next =NULL;//最后一个迟早是NULL
	q.rear = p;//修改表尾指针
}
```

##### 入队（不带头节点）

![image-20220319123435952](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319123435952.png)

##### 出队(带头结点)

![image-20220319124106355](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319124106355.png)

```c++
bool deQueue(LinkQueue& q, ElementType& type) {
	if (q.front == q.rear)
	{
		return false;
	}
	QNodeptr deleteOne = q.front->next;//要删除的结点就是头节点后面一个的结点
	type = deleteOne->data;
	q.front->next = deleteOne->next;
	if (deleteOne = q.rear)//如果删除是最后一个结点
	{
		q.rear = q.front;
	}
	delete(deleteOne);
	return true;
}
```

##### 出队（不带头结点）

![image-20220319124246196](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319124246196.png)

##### 队列满的条件

![image-20220319124346519](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319124346519.png)

##### 总结

![image-20220319124417634](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319124417634.png)

#### 双端队列

![image-20220319124723748](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319124723748.png)

![image-20220319124756166](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319124756166.png)

##### 考点

###### 栈

![image-20220319125201947](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125201947.png)



![image-20220319125235933](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125235933.png)

###### 输入受限双端队列

![image-20220319125449881](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125449881.png)

![image-20220319125552719](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125552719.png)

###### 输出受限的双端队列

![image-20220319125638317](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125638317.png)

![image-20220319125747521](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125747521.png)

##### 卡特兰数

![image-20220320155436066](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220320155436066.png)

![image-20220319125259745](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220319125259745.png)

#### 队列的应用

##### 树的层次调用

![image-20220331213607247](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331213607247.png)

##### 图的广度优先遍历

![image-20220331213836740](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331213836740.png)

##### 操作系统的应用

![image-20220331213915419](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331213915419.png)

![image-20220331214004157](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331214004157.png)

### 特殊矩阵的压缩存储

![image-20220331214126039](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331214126039.png)

![image-20220331214349335](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331214349335.png)



> 可以实现随机存取，

![image-20220331214546704](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331214546704.png)

#### 行优先

![image-20220331214754241](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220331214754241.png)

#### 列优先

![image-20220401093228807](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401093228807.png)

#### 对称矩阵的压缩存储

##### 行优先

> aij=aji
>
> 压缩矩阵的策略，只存储上三角区和对角线元素，或者只存储下三角区和对角线元素。

![image-20220401142700030](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401142700030.png)



![image-20220401142715937](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401142715937.png)

##### 设置多大数组？

> 第一个问题
>
> 我们的数组应该要设置多大才行？能把对称矩阵压缩后全部放进去？
>
> 观察得：第一行一个元素，第二行两个元素。一共有n行。则1+2+....n=n(n+1)/2，因为数组是从0开始，所以还要-1

![image-20220401093625806](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401093625806.png)

##### 如何对应矩阵下标？

> 第二个问题？
>
> 用矩阵的下标来访问元素，而不是用数组的下标访问元素。设置一个映射函数。
>
> 如果按行优先。例如a32,在a32前面，有3-1行，有2-1列
>
> 所以aij有 i-1行，j-1列。
>
> 那么aij前面有几个元素呢？
>
> 对于行：第一行有一个元素，那么i-1行有  1+2+....i-1个元素。
>
> 对于列：aij前面肯定有j-1个元素，但是aij是第j个元素。
>
> 所以综上，aij是第 1+2+....i-1+j个元素
>
> 如果对应数组下标k，如果数组下标从0开始，那还要-1

![image-20220402204927010](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220402204927010.png)



![image-20220402205624901](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220402205624901.png)

##### 列优先

![image-20220401155448216](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401155448216.png)

![image-20220401160730499](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401160730499.png)

![image-20220402211424259](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220402211424259.png)

> 如何对应数组下标？
>
> 例如 aij,因为是列优先。列数是从1~j-1的。第一列有n(n是总列数)个元素，第二列有n-1,第j-1列有n-(j-1-1)个元素。
>
> （i-j）是行号减去列号，表示这一列前面还有多少个元素。前面有i-j个，最后自己的位置肯定是i-j+1个，但是注意下标是不是从0开始的。

#### 三角矩阵的压缩存储

##### 行优先

![image-20220401160848629](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401160848629.png)

数组的长度是1+2+....n，但是最后还需要一个位置存放常量

![image-20220401160950591](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401160950591.png)

如何映射为数组下标？

> 为什么最后一个元素是n(n+1)/2呢？因为一共需要1+...+n个位置存储，按道理应该是0~n(n+1)/2-1了对吧？但是还有个常数，常数放在最后一个位置，也就是n(n+1)/2

![image-20220401212839827](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401212839827.png)

> i-1是因为，a ij 前面肯定有i-1行

![image-20220402212806293](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220402212806293.png)

#### 三对角矩阵的压缩存储

行号和列号绝对值相差大于1的时候，元素就等于0

![image-20220401213331013](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401213331013.png)

除了第一行和最后一行，其他行都是三个元素。所以一共有3n-2个元素，所以长度就是这么多。

![image-20220401213508107](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401213508107.png)

如何对应数组下标？

![image-20220401213707261](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220401213707261.png)

> 为什么是3(i-1)-1,
>
> i-1是因为aij前面肯定有i-1行。每行3个元素，所以是3（i-1），但是第一行只有两个，所以是3（i-1）-1；
>
> 为什么是j-i+2?
>
> 看图就知道了。比如a12 ,2-1+2=3。
>
> a33 就是 0-0+2=2;
>
> a23就是3-2+2=3

## 串

### 定义和基本操作

![image-20220403161742408](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403161742408.png)

![image-20220403162000753](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403162000753.png)

> 串是位序，下标是从1开始的。
>
> 例如T是一个空串，S是iphone 11 pro max。
>
> subString(&T,S,4,6);就是把S从第四个字符开始，往后截六个，得到的子串赋值给T。所以T=one 11
>
> index(S,W);就是找到子串在主串中第一次出现的位置。例如S是iphone 11 pro max，W是pro,index就是11。

![image-20220403163711566](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403163711566.png)

![image-20220403163916433](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403163916433.png)

![image-20220403164117600](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403164117600.png)

![image-20220403164240545](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403164240545.png)

![image-20220403164409605](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403164409605.png)

![image-20220403164417784](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403164417784.png)

### 串的存储结构

![image-20220403165225456](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403165225456.png)

>  串的顺序存储

![image-20220403171708458](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403171708458.png)

> 串的链式存储

![image-20220403171933204](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403171933204.png)

### 求子串subString

> 为什么是pos + len-1 > oldString.length？
>
> pos+len就是新字符串的长度，那为什么-1呢？因为从哪里截取的字符那个地方开始，也算是一个字符，
>
> 比如 a b c d e f g ,从第三个开始截取，c算是第一个字符。
>
> 比如老字符串有9个数，新的从第六个开始截取，能截取四个，6 7 8 9嘛，包含6本身。6+4-1嘛。
>
> 为什么i < pos+len？
>
> 从pos开始，循环len次。
>
> 为什么i - pos + 1？
>
> 因为第一个位置不存数据的。i每次都比pos多1

```c++
//求子串,返回由pos起，长度为len的子串
bool subString(SString &newString,SString oldString,int pos,int len) {
	if (pos + len-1 > oldString.length) return false;
	for (int i = pos; i < pos+len; i++)
	{
		newString.ch[i - pos + 1] = oldString.ch[i];
	}
	newString.length = len;
	return true;
}
```

![image-20220403182234515](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403182234515.png)

### 比较串的大小strCompare

```c++
int strCompare(SString& string1, SString& string2) {
	int len = string1.length > string2.length ? string2.length : string1.length;
	for (int i = 0; i < len; i++)
	{
		if (string1.ch[i]!=string2.ch[i]) {
			return  string1.ch[i] - string2.ch[i];
		}
	}
	return string1.length-string2.length;
}
```

![image-20220403183904940](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403183904940.png)

### 定位操作index

> 为什么是len1-len2+1呢？
>
> len1-len2代表后面有len1-len2个空闲位置，那为什么+1呢？因为后面有那么多空闲位置，但是前面还有len2这一个位置

```c++
int index(SString string1,SString string2) {
	int len1 = string1.length;//原始长度7
	int len2 = string2.length;//取的长度3
	SString sub;
	int i=1;
	while (i<=len1-len2+1)
	{
		subString(sub,string1,0,len2);
		if (strCompare(string2, sub) != 0) ++i;
		else return i;
	}
	return 0;
}
```

### 朴素模式匹配算法

![image-20220403194804574](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403194804574.png)

> 为什么是i-j+2?
>
> 因为每次i和j都会移动到一样的位置上去,i-j的作用相当于是回到起点前面的一个位置，然后再加2，因为加1是回到起点，+2就是右移了一个位置。

![image-20220403210413216](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403210413216.png)

> 为什么最后返回的是j>T.length,因为最后会指向最后一个元素的下一个位置。
>
> 为什么是i-T.length?如图

![image-20220403210949019](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220403210949019.png)

```c++
int index2(SString string1, SString string2) {
	int len1 = string1.length;//原始长度7
	int len2 = string2.length;//取的长度3
	int i = 1, j = 1;
	while (i<=len1&&j<=len2)
	{
		if (string1.ch[i]==string2.ch[j]) {
			++i; ++j;
		}
		else
		{
			i = i - j + 2;
			j = 1;
		}
	}
	if (j==string2.length)
	{
		return i - string2.length;
	}
	return 0;
	
}
```

#### 时间复杂度分析

### KMP算法

![image-20220404113729165](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404113729165.png)

> 如果在6号位置匹配失败，按照朴素模式的算法，会在二号位置开始重新匹配，从2到模式串的长度。

#### 回顾朴素模式

![image-20220404120555990](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404120555990.png)

![image-20220404121048652](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404121048652.png)

#### 演示1

> 现在换个思路,如果第一个子串我们匹配到最后一个字符，才匹配失败。那说明前面五个字符是已知的，和模式串肯定是保持一致的，可以跳过很多不必要的对比。

![image-20220404122357357](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404122357357.png)

![image-20220404122021920](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404122021920.png)

![image-20220404122449480](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404122449480.png)

#### 演示2

> 再来演示一遍

![image-20220404122635291](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404122635291.png)

![image-20220404122826685](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404122826685.png)

#### 其他情况演示

> 如果第五个失配

![image-20220404123008997](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123008997.png)

![image-20220404123051840](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123051840.png)

> 如果第四个失配

![image-20220404123120105](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123120105.png)

![image-20220404123200390](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123200390.png)

> 第三个元素失配

![image-20220404123238965](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123238965.png)

![image-20220404123255585](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123255585.png)

> 第二个元素失配

![image-20220404123325640](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123325640.png)

![image-20220404123341439](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123341439.png)

> 第一个元素失配

![image-20220404123413116](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123413116.png)

![image-20220404123446327](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123446327.png)

#### 总结

![image-20220404123508149](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123508149.png)

![image-20220404123540639](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123540639.png)

![image-20220404123556281](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123556281.png)

![image-20220404123611985](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123611985.png)

![image-20220404123654645](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123654645.png)

![image-20220404123706406](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123706406.png)

![image-20220404123804244](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123804244.png)

![image-20220404123821072](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123821072.png)

![image-20220404123835546](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123835546.png)

![image-20220404123845581](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123845581.png)

![image-20220404123854729](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123854729.png)

![image-20220404123910813](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123910813.png)

![image-20220404123931421](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123931421.png)

![image-20220404123953869](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404123953869.png)

#### 代码初步实现

![image-20220404124129638](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404124129638.png)

![image-20220404124259231](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404124259231.png)

```c++
int kmpIndex(SString string1,SString string2,int next[]) {
	int length1 = string1.length;
	int length2 = string2.length;
	int i = 1, j = 1;
	while (i<=length1&&j<=length2)
	{
		if (j==0||string1.ch[i]==string2.ch[j]) {
			++i;
			++j;
		}
		else
		{
			j = next[j];
		}
	}
	if (j>string2.length)
	{
		return j - length2;
	}
	return 0;
}
```

### 求next数组

> 为什么next[1]无脑写0
>
> 如果第一个字符就开始不匹配了，那么先让j=0,然后i和j同时++
>
> 为什么让j=0,因为j++之后，变成模式串第一个字符，为什么i++,因为i要后移。意思就是说i后移，和模式串的第一个重新对比。

![image-20220404155552762](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404155552762.png)

> 为什么next[2]无脑写1？
>
> 如图

![image-20220404184345918](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404184345918.png)

![image-20220404184358979](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404184358979.png)

> 在不匹配的前面， 画上一根分界线

![image-20220404160655755](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404160655755.png)

![image-20220404160130605](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404160130605.png)

#### 练习

![image-20220404161147221](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404161147221.png)

#### 2021版本求next数组

> 这是什么意思呢？
>
> 串的前缀：指的是模式串中，包含第一个字符，但是不包含最后一个字符。
>
> 串的后缀：指的是主串中，包含最后一个字符，但是不包含第一个字符。
>
> 如何通过串的前缀和后缀知道next数组呢？
>
> 例如左边的例子：
>
> 当第7个字符匹配失败的时候，前面1~6个组成的串记作S，
>
> 所以模式串的S是：ababab,前缀是ababa,后缀是babab
>
> 最大相等前后缀长度是abab+1，也就是4+1=5，所以当7不匹配的时候，next[j]的值是5

![image-20220404181705945](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404181705945.png)

#### 印度小哥讲KMP

![image-20220404195249732](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404195249732.png)

> 很明显x和d不匹配，然后看d之前的abc,有没有前缀和后缀相同的情况，意味着我们下一次比较要从模式串的第一个开始

![image-20220404205044731](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220404205044731.png)

#### 天勤率辉讲KMP

##### 手工求解

> KMP算法，仅仅后移模式串，主串指针不回溯。
>
> 移动模式串，使得公共前后缀的前缀移动到后缀原来的位置。

![image-20220405173305893](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405173305893.png)

![image-20220405180335131](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405180335131.png)

> 再来个例子

![image-20220405180501659](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405180501659.png)

![image-20220405180511950](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405180511950.png)

> 再来个例子

找最长公共前后缀，

前缀：ABBAB,后缀：BBABA,

![image-20220405180627197](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405180627197.png)

![image-20220405181022476](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405181022476.png)

![image-20220405181032060](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405181032060.png)

> 再来个例子

![image-20220405190715505](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405190715505.png)

如果取本身作为公共前后缀，没有意义，因为这样就不要移动了

![image-20220405190804293](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405190804293.png)

![image-20220405190851027](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405190851027.png)

![image-20220405190911203](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405190911203.png)

![image-20220405190925268](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405190925268.png)

![image-20220405190940825](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405190940825.png)

> 转化为计算机方便处理的方式：
>
> 因为一直在移动模式串，所以直接把主串先去掉，和主串没关系

![image-20220405191054386](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191054386.png)

![image-20220405191045413](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191045413.png)

> 模式串放在数组下标中

![image-20220405191131376](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191131376.png)

> 1.如果第一个位置不匹配

![image-20220405191243583](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191243583.png)

![image-20220405191255541](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191255541.png)

> 如果二号位不匹配，找公共前后缀
>
> 发现箭头左边的子串长度是1，公共前后缀的长度是0，模式串移动到图二位置，移动后左边子串长度就是公共前后缀的长度。所以移动后左边子串长度变成0.

![image-20220405191329906](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191329906.png)

![image-20220405191442574](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191442574.png)

> 如果三号位不匹配，和二号一样，公共前后缀长度为0

![image-20220405191636904](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191636904.png)

> 如果四号位长度不匹配，公共前后缀长度为1，所以箭头左边长度是1

![image-20220405191748212](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191748212.png)

![image-20220405191812988](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191812988.png)

> 如果五号位长度不匹配，公共前后缀长度是AB,所以箭头左边要留两个位置

![image-20220405191905228](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191905228.png)

![image-20220405191955987](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405191955987.png)

> 如果六号位不匹配，找公共前后缀，发现长度是3，所以箭头左边有三个元素

![image-20220405192037599](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405192037599.png)

![image-20220405192117360](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405192117360.png)

> 得到结论，当前公共前后缀的长度为3的话，那就是四号位与主串比较，如果公共前后缀长度为n,那么就得到，n+1号位与主串当前位开始比较。得到next数组如下：

![image-20220405192349791](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405192349791.png)

##### 代码求解

假设有一个模式串如下，假设next[j]=t,已经求得了。

![image-20220405192803256](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405192803256.png)

将它复制一份，红色的部分是最长公共前后缀，因为next[j]=t。pj的下一项是pt,

下面是前缀，上面是后缀。



![image-20220405192848689](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405192848689.png)

![image-20220405210951902](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220405210951902.png)

> 这个图是什么意思呢？意思是求Next数组的时候，next[j]的值应该取什么？
>
> next[j]是什么呢？是在j位置发生不匹配的时候，模式串的j应该移动到什么位置，避免移动到1嘛，不一定就是从1开始的。
>
> p1....pk-1是什么意思呢？本来k就是最长公共前后缀的长度再加1的。1~k-1的意思是前缀的长度，这个很好理解吧？
>
> 至于j-k+1如何理解呢？j-k的意思就是从第j个位置开始，往左移k个元素，这个时候是不是移动到后缀的前一项了？因为k是最长公共前后缀+1嘛。在-1的话，就是后缀的长度了。
>
> 0是什么意思呢？j=1的时候，指向第一个元素嘛。此时没有公共最长前后缀。
>
> 1是什么意思呢？就是除开有公共前后缀的情况，除开集合非空的情况，那是什么情况呢？比如 ab ,指向b的时候，有前缀，有后缀，但是就是没有公共前后缀。
>
> 所以next数组求解就是这样的过程了。
>
> 

![image-20220406213231010](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220406213231010.png)

![image-20220406214113329](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220406214113329.png)

## 树与二叉树

### 树

#### 树的定义和基本术语

![image-20220412211510888](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412211510888.png)

##### 树的基本概念

> 每个结点有且只有一个前驱

![image-20220412211548268](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412211548268.png)

> 树是由一个根结点，和互不相交的子树构成的

![image-20220412212107711](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412212107711.png)

![image-20220412212151486](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412212151486.png)

> 树的例子

![image-20220412212304849](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412212304849.png)

##### 结点之间的关系描述

> 祖先结点：从一个结点出发，然后一直往上走，直到走到根节点为止，路径上经过的所有的结点，都是这个结点的祖先结点

![image-20220412212705833](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412212705833.png)

> 子孙结点：从一个结点出发，它的这些分支，下面长出的果实，都是它的子孙结点
>
> 你，F ，K,L都是父亲的子孙结点

![image-20220412213015711](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412213015711.png)

> 双亲（父）结点：一个结点的直接前驱，就是父节点



> 孩子结点：一个结点的直接后继，就是父节点

> 兄弟结点：你和F

![image-20220412213120084](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412213120084.png)

> 堂兄弟结点：在同一层的结点

![image-20220412213206681](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412213206681.png)

> 结点之间的路径：只能从上到下，从你到G，就没有路径 
>
> 路径的长度：从一个结点到另外一个结点经过了几条边

![image-20220412213317191](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412213317191.png)

##### 结点、树的属性描述

![image-20220412214527639](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412214527639.png)

> 结点的度

![image-20220412214849139](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412214849139.png)

##### 有序树、无序树

![image-20220412215030561](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412215030561.png)

##### 树和森林

![image-20220412215144569](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412215144569.png)

![image-20220412215153856](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220412215153856.png)

#### 树的性质

##### 结点数

![image-20220413160758939](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413160758939.png)

##### 度为m和m叉树

![image-20220413160927959](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413160927959.png)

##### 度为m的第i层最多结点数

![image-20220413161105405](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413161105405.png)

##### 高度为h的m叉树最多结点

![image-20220413161204606](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413161204606.png)

##### 高度为h的m叉树最少结点

![image-20220413161334885](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413161334885.png)

##### n个结点的m叉树最小高度

![image-20220413161549444](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413161549444.png)

##### 总结

> 1.结点数=总度数+1
>
> 2.度为m和m叉树的区别在于：
> 度为m的树一定是非空树，至少有m+1个结点。而且至少有一个结点是m个度
> m叉树允许是空树，允许所有的度都小于m。
>
> 3.度为m的第i层，最多的结点数：m^(i-1)
>
> 4.高度为h的m叉树，最多结点数：m^0+m^1+....m^h-1=(m^h-1)/m-1
>
> 5.高度为h的m叉树，最少结点数：h+(m-1)
>
> 6.n个结点的m叉树最小高度：logm(n(m-1)+1),向上取整

### 二叉树

#### 概念

![image-20220413184901227](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413184901227.png)

![image-20220413184853091](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413184853091.png)

#### 几种特殊的二叉树

##### 满二叉树



![image-20220413185314476](C:/Users/CAP/AppData/Roaming/Typora/typora-user-images/image-20220413185314476.png)

##### 完全二叉树

![image-20220413185506367](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413185506367.png)

![image-20220413185619524](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413185619524.png)

![image-20220413185650702](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413185650702.png)

##### 二叉排序树

![image-20220413185840016](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413185840016.png)

##### 平衡二叉树

![image-20220413190028128](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413190028128.png)

##### 总结

![image-20220413190117848](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413190117848.png)

#### 性质

##### n0=n2+1

![image-20220413153651379](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413153651379.png)

##### 第i层最多结点数

![image-20220413154019640](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413154019640.png)

##### 高度为h的二叉树最多结点数

![image-20220413190511882](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413190511882.png)

##### n个结点的完全二叉树高度

![image-20220413190734389](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413190734389.png)

![image-20220413190916278](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413190916278.png)

##### 由结点个数推n0,n1,n2

![image-20220413192116105](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413192116105.png)

##### 总结

1.n0=n2+1

总结点数=n=1+n1+2n2

n=n0+n1+n2

两式相减得到n0=n2+1。

2.第i层最多结点数：2^(i-1)

3.高度为h的二叉树最多结点数:(2^h)-1

![image-20220506101429697](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220506101429697.png)

4.n个结点的完全二叉树的高度h=log2(n+1)向上取整

![image-20220506102431192](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220506102431192.png)

5.由结点数推 n0,n1,n2

#### 二叉树的存储结构

##### 顺序存储

![image-20220413204535745](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413204535745.png)

![image-20220413204520122](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413204520122.png)

![image-20220413204843166](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413204843166.png)

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413205219777.png"/>

![image-20220413205258424](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413205258424.png)

```c++
#include<iostream>
using namespace std;
#define MAXSIZE 100
typedef  char  ElementType;
typedef struct TreeNode {
	ElementType *value;
	bool isEmpty;
}TreeNode;
TreeNode treeNode[MAXSIZE];
bool initTreeNode() {
	for (int i = 0; i < MAXSIZE; i++)
	{
		treeNode[i].isEmpty = true;
	}
	return true;
}
```

##### 链式存储

![image-20220413205409089](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413205409089.png)

![image-20220413210234883](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413210234883.png)

```c++
#include<iostream>
using namespace std;
typedef char ElementType;
typedef struct BiTNode {
	ElementType data;
	struct BiTNode* lChild, * rChild;
}BiTNode,* BiTree;

bool initTree(BiTree &tree) {
	tree = NULL;
	tree = new BiTNode;
	tree->data = 1;
	tree->rChild = NULL;
	tree->lChild = NULL;
	return true;
}

bool insertTree(BiTree& tree) {
	BiTree newNode = new BiTNode;
	newNode->data = 2;
	newNode->rChild = NULL;
	newNode->lChild = NULL;
	tree->lChild = newNode;
}
```



###### 总结

![image-20220413210353781](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413210353781.png)

![image-20220413210344139](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220413210344139.png)

#### 先中后序遍历

先把总体的代码放这

```c++
#include<iostream>
#include<stack>
#include<queue>
using namespace std;
typedef struct BiNode {
	char data;
	BiNode* lChild, * rChild;
}BiNode, * BiTree;
void createBiTree(BiTree& T) {
	char ch;
	cin >> ch;
	if (ch == '#')  T = NULL;
	else {
		T = new BiNode;
		T->data = ch;
		createBiTree(T->lChild);
		createBiTree(T->rChild);
	}
}
void visit(BiTree T) {
	cout << T->data;
}
void inOrder(BiTree T) {
	stack<BiTree> stackTree;
	BiTree p = T;
	while (p||!stackTree.empty())
	{
		if (p)
		{
			stackTree.push(p);
			p = p->lChild;
		}
		else
		{
			p=stackTree.top();
			stackTree.pop();
			visit(p);
			p = p->rChild;
		}
		
	}
}
void preOrder(BiTree T) {
	stack<BiTree> stackTree;
	BiTree p = T;
	while (p || !stackTree.empty())
	{
		if (p)
		{
			visit(p);
			stackTree.push(p);
			p = p->lChild;
		}
		else
		{
			p = stackTree.top();
			stackTree.pop();
			p = p->rChild;
		}

	}
}
void levelOrder(BiTree T) {
	queue<BiTree> treeQueue;
	BiTree p=T;
	treeQueue.push(p);
	while (!treeQueue.empty())
	{
		p = treeQueue.front();
		visit(p);
		treeQueue.pop();
		if (p->lChild!=NULL)
		{
			treeQueue.push(p->lChild);
		}
		if (p->rChild != NULL)
		{
			treeQueue.push(p->rChild);
		}
		
	}
}
//https://blog.csdn.net/stpeace/article/details/8138458
int depth(BiTree T)
{
	if (NULL == T) 		return 0;
	int leftDepth = depth(T->lChild);
	int rightDepth =depth(T->rChild);
	return 1 + max(leftDepth, rightDepth);
}	
void printNodeAtLevel(BiTree T, int level)
{
	// 空树或层级不合理
	if (NULL == T || level < 1)
		return;
	if (1 == level)
	{
		//cout << T->data << "  ";
		cout << T->data;
		return;
	}

	// 左子树的 level - 1 级
	printNodeAtLevel(T->lChild, level - 1);

	// 右子树的 level - 1 级
	printNodeAtLevel(T->rChild, level - 1);
}


void levelTraverse(BiTree T)
{
	if (NULL == T)
		return;

	int depthNumber = depth(T);
	cout << "高度为" << depthNumber << endl;

	int i;
	for (i = 1; i <= depthNumber; i++)
	{
		printNodeAtLevel(T, i);
		//cout << endl;
	}
}



int main() {
	BiTree T;
	createBiTree(T);
	cout << "中序遍历：" << endl;
	inOrder(T);
	cout << endl;
	cout << "先序遍历：" << endl;
	preOrder(T);
	cout << endl;

	cout << "非递归层序遍历：" << endl;
	levelOrder(T);
	cout << endl;

	cout << "递归层序遍历：" << endl;
	levelTraverse(T);
	cout << endl;
	return 0;
}
```



遍历的顺序其实就看根在哪个位置，比如先序遍历就是根左右

中序遍历就是左根右

后序遍历就是左右根

![image-20220506104548675](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220506104548675.png)

![image-20220506105216984](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220506105216984.png)

##### 递归代码实现

> CG

递归创建树：

中序遍历的输入样例：1 2 4 # # 5 # # 3 # 6 7 # # #

输入数字就New 一个结点。

![image-20220514150000931](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514150000931.png)

```c++
void CreateBiTree(BiTree& T) {
	char ch;
	cin >> ch;
	if (ch == '#')  T = NULL;
	else {
		T = new BiTNode;
		T->data = ch;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
	}
}
```

递归遍历树

![image-20220514152315712](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514152315712.png)

一层一层遍历，到4的时候，1，2，3部分代码都执行完了，只输出4.

4的上一层刚刚好是2，2的1部分代码执行完了，也就是左子树遍历过了。接下来输出2，再执行3部分代码，也就是输出5.

这就刚刚好是一个左根右。

```c++
void InOrderTraverse(BiTree& T)
{
	if (T)
	{
		InOrderTraverse(T->lchild);
		cout << T->data;
		InOrderTraverse(T->rchild);
	}
}
```

完整代码如下：

```c++
#include<iostream>
using namespace std;
typedef struct BiNode {
	char data;
	struct BiNode* lchild, * rchild;
}BiTNode, * BiTree;


void CreateBiTree(BiTree& T) {
	char ch;
	cin >> ch;
	if (ch == '#')  T = NULL;
	else {
		T = new BiTNode;
		T->data = ch;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
	}
}

void InOrderTraverse(BiTree& T)
{
	if (T)
	{
		InOrderTraverse(T->lchild);
		cout << T->data;
		InOrderTraverse(T->rchild);
	}
}


int main() {
	BiTree tree;
	CreateBiTree(tree);
	InOrderTraverse(tree);
	cout << endl;
}

```

> 王道，讲解递归过程

![image-20220513173108741](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220513173108741.png)

##### ==非递归代码实现==

首先建立一棵树。怎么理解呢？比如输入序列是

【输入形式】1 2 4 # # 5 # # 3 # 6 7 # # #

那么首先new 一个结点，然后递归的创建他的左子树，输入到4的时候，然后两个#导致`4全部出栈`，

4出栈之后，栈中还有2的右子树，此时5就是2的右子树，`2出栈`两个#导致`5全部出栈`，

输入3，`1出栈`3左子树为空，右子树为6，`3出栈`6的左子树为7，`7因为两个#出栈`。最后一个 #导致`6出栈`

总体上说，树是这样的：

​        1

  2           3

4   5              6

​                 7

```c++
void CreateBiTree(BiTree& T) {
	char ch;
	cin >> ch;
	if (ch == '#')  T = NULL;
	else {
		T = new BiTNode;
		T->data = ch;
		CreateBiTree(T->lchild);
		CreateBiTree(T->rchild);
	}
}
```

非递归方式要使用到栈结构，先进，后出。因为递归也是栈。

``中序遍历``：

中序遍历的流程是：左根右

如果根节点不为空，就进栈，然后把左孩子都先入栈，栈的特点是先进后出

比如先入栈 1 2 4，4的左孩子为空，进入else

p=4，4出栈，然后访问4,然后看看4有没有右孩子，发现也没有

p=2，2出栈，然后访问2，看看2有没有右孩子，发现有5，进入if，把5入栈

....

总结起来就是都去找左边的，左边的优先进栈，如果左边没有左孩子了，那就左边的叶子节点（或者是有右子树的根节点）出栈，

如果是有右孩子那就入栈，右孩子是叶子结点的话就直接出栈，如果不是叶子结点就继续访问，左边的优先入栈，左边的是空了，进入else了，就把栈顶的左边的先出栈，然后能入栈的就入栈。

因为肯定是左子树的先出栈

> 左边的能进则进，什么叫能进？就是还有左子树的，就进栈，如果没有左子树说明以及到达最左，假设为A，可以放心出栈
>
> 如果A还有右节点，问题不大，序列是左根右，不会影响。因为此时A是根节点了，也应该先出栈。

```c++
void inOrder(BiTree T) {
	stack<BiTree> stackTree;
	BiTree p = T;
	while (p||!stackTree.empty())
	{
		if (p)
		{
			stackTree.push(p);
			p = p->lChild;
		}
		else
		{
			p=stackTree.top();
			stackTree.pop();
			visit(p);
			p = p->rChild;
		}
		
	}
}
```

``先序遍历``

​      1

  2           3

4   5              6

​                 7

根左右，先出栈根，所以要先visit根，也就是只要不为空的，都先visit。

比如1不为空，就visit 1

1的左，不为空就visit 2

2的左，不为空就visit 4

4的左，为空就else,将2出栈，并且访问2的右子树

```c++
void preOrder(BiTree T) {
	stack<BiTree> stackTree;
	BiTree p = T;
	while (p || !stackTree.empty())
	{
		if (p)
		{
			visit(p);
			stackTree.push(p);
			p = p->lChild;
		}
		else
		{
			p = stackTree.top();
			stackTree.pop();
			p = p->rChild;
		}

	}
}
```





#### ==层次遍历==

##### 思想

层次遍历比较简单，就是一层一层的遍历，比如h层的树，0~h-1层的每一层的结点，从左至右输出	

思想是：

``1.用一个队列``

``2.让根节点入队``

``3.如果队列不是空的话，队头出列，访问该结点，并且将其左右孩子插入队尾（如果有的话）``

![image-20220510171741865](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510171741865.png)

##### 代码实现

层次遍历使用队列

值得注意的是，队列中的值保存的并不是这个结点，而是这个结点的指针。因为一个指针占用的空间肯定是比一个结点占用的空间小的。

所以入队，入队的时候，都是p->lchild，或者p->rchild

![image-20220510171806745](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510171806745.png)

``递归方式：``

```c++
int depth(BiTree T)
{
	if (NULL == T) 		return 0;
	int leftDepth = depth(T->lChild);
	int rightDepth =depth(T->rChild);
	return 1 + max(leftDepth, rightDepth);
}	
void printNodeAtLevel(BiTree T, int level)
{
	// 空树或层级不合理
	if (NULL == T || level < 1)
		return;
	if (1 == level)
	{
		//cout << T->data << "  ";
		cout << T->data;
		return;
	}

	// 左子树的 level - 1 级
	printNodeAtLevel(T->lChild, level - 1);

	// 右子树的 level - 1 级
	printNodeAtLevel(T->rChild, level - 1);
}


void levelTraverse(BiTree T)
{
	if (NULL == T)
		return;

	int depthNumber = depth(T);
	cout << "高度为" << depthNumber << endl;

	int i;
	for (i = 1; i <= depthNumber; i++)
	{
		printNodeAtLevel(T, i);
		//cout << endl;
	}
}
```

`非递归方式`

```c++
void levelOrder(BiTree T) {
	queue<BiTree> treeQueue;
	BiTree p=T;
	treeQueue.push(p);
	while (!treeQueue.empty())
	{
		p = treeQueue.front();
		visit(p);
		treeQueue.pop();
		if (p->lChild!=NULL)
		{
			treeQueue.push(p->lChild);
		}
		if (p->rChild != NULL)
		{
			treeQueue.push(p->rChild);
		}
		
	}
}
```



#### 遍历序列构造二叉树

> 问题引入
>
> 如果只给你一个前序序列，让你逆推出他的二叉树的形态能不能行？

答案是不行的，同一个序列，会有多种不同的二叉树形态

![image-20220510172129388](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172129388.png)

结论：一定要两种序列，而且必须要中序序列。

![image-20220510172206366](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172206366.png)

给出几个例题：

##### 前+中恢复二叉树

``前序遍历序列的第一个肯定是根节点``

eg1

![image-20220510172258776](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172258776.png)

eg2

![image-20220510172338530](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172338530.png)

![image-20220510172359240](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172359240.png)

![image-20220510172411160](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172411160.png)

##### 后+中恢复二叉树

``后序的最后一个结点，肯定是根节点``

![image-20220510172533288](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510172533288.png)

##### 层序+中恢复二叉树

``层序遍历的第一个结点肯定是根节点``

![image-20220510173051645](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510173051645.png)

![image-20220510173330871](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510173330871.png)

![image-20220510173341338](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510173341338.png)

#### 线索二叉树

为什么要线索二叉树？

1.是因为遍历二叉树的时候，每次都只能从根结点开始遍历，只有我们知道根节点是哪个，才能遍历。

如果有一个场景，我们只能知道一个结点的指针，比如G结点的指针，还能不能从G除法，进行中序遍历呢？显然是完成不了的。

之前的线性表，给你一个元素的指针，至少是能遍历这个指针的后面的元素的，但是对于二叉树，是做不到的。

2.能不能找一个结点的前驱呢？能，这样操作：

先进行一次中序遍历，因为先遍历的左节点。到D的时候停下遍历，因为D->lChild是空，这时候执行下一行Visit（T），让指针q指向D这个结点，让pre指向D的前驱，也就是NULL。对比一下q和p没有指向同一个结点，继续中序遍历。

![image-20220510174339876](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510174339876.png)

最后会运行到这个地方，pre就指向了p的前驱了。

如果要找到p的后继，那么就是判断pre==p,如果等于了的话,q就是p的后继了。

![image-20220510175408694](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510175408694.png)

``用空链域记录前驱后继的信息``

但是对于B结点，B的前驱是A，但是左孩子是D，这种情况怎么办呢？后面再探讨

![image-20220510175540109](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510175540109.png)

##### 存储结构

![image-20220510175825476](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510175825476.png)

```c++
#include<iostream>
using namespace std;
typedef int ElementType;
typedef struct BiTNode {
	ElementType data;
	 BiTNode* lChild, *rChild;
	 int lTag, rTag;//tag ==0---表示指针指向孩子，tag==1,表示指针是线索。
}BiTNode,* BiTree;
```

中序前驱，就是中序遍历时候的某一个结点的前驱。

![image-20220510175849021](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510175849021.png)

![image-20220510175920981](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220510175920981.png)

####  `` 1二叉树线索化``

线索化的作用是找前驱，如果不线索化就用土办法

##### 土办法

> 什么意思呢？就是要找某一个结点的中序前驱。那就用中序遍历的方法==从头开始==找。

![image-20220524091823132](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524091823132.png)



![image-20220512205943010](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220512205943010.png)

```c++
#include<iostream>
using namespace std;
typedef char ElementType;
typedef struct BiNode {
	ElementType data;
	BiNode* lChild, * rChild;
}BiNode,* BiTree;
BiNode* p;
BiNode* pre=NULL;
BiNode* finalNode = NULL;
void visit(BiNode *q) {
	//p是要找的结点，比如要找A结点，就中序遍历一遍树，然后看树的哪一个结点和A是一样的
	if (q=p) finalNode = pre;
	//如果还不一样，pre就指向当前结点，因为要访问下一个结点了。
	else pre = q;
}
void inOrder(BiTree tree) {
	if (tree!=NULL)
	{
		inOrder(tree->lChild);
		visit(tree);
		inOrder(tree->lChild);
	}
}
```

##### 线索化

###### 中序线索化

叶子结点的ltag和rtag都设置为0.表示没有被线索化过.

1.第一个被visist的结点是D，看到D的左子树为空，让D的左子树指向pre,ltag改成1把pre改成当前结点。

此时pre==NULL,不执行第二个if

pre=q;也就是此时的pre是D。

2.然后visit的结点是G，G的左子树是null，然后让G的左子树指向pre，也就是D结点。

此时pre的右孩子不为空，不执行第二个if

pre=q，此时的pre是G。

3.然后visit的结点是B，B的左不为空。第一个if不执行。

然后看pre是不是空，pre的右孩子是不是空，发现满足第二个if，让pre也就是G的右孩子指向B，把rtag=1

再把pre=q，此时的pre是B

4.然后visit的是E，E的左孩子是空，把E的左孩子指向pre

......

![image-20220519215404734](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220519215404734.png)

![image-20220519215333465](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220519215333465.png)

![image-20220524120002163](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524120002163.png)

```c++
#include<iostream>
using namespace std;

typedef  char ElementType;
typedef struct ThreadNode {
	ElementType data;
	ThreadNode* lChild, * rChild;
	int lTag, rTag;
}ThreadNode, * ThreadTree;

ThreadNode* pre = NULL;

void inThread(ThreadTree tree) {
	if (tree!=NULL)
	{
		inThread(tree->lChild);
		visit(tree);
		inThread(tree->rChild);
	}
}
/*
* 对于D结点，pre本来就是指向NULL的。此时第一个结点的左孩子==NULL，
  所以就线索化，让它的左孩子指向前驱，也就是NULL
*/

void visit(ThreadNode * nowNode) {
	if (nowNode->lChild==NULL)
	{
		nowNode->lChild = pre;
		nowNode->lTag = 1;
	}

	//对于B结点,B的前驱G是没有右孩子的，所以要指向后继B
	if (pre!=NULL&&pre->rChild==NULL)
	{
		pre->rChild = nowNode;
		pre->rTag = 1;
	}
	//pre指针指向当前结点
	pre = nowNode;
}

void createInthread(ThreadTree tree) {
	pre = NULL;
	if (tree!=NULL)
	{
		inThread(tree);
		//这时候inThread线索化完了，pre指向C结点，但是C结点是应该被线索化的。所以最后处理一下
		if (pre->rChild==NULL)
		{
			pre->rTag = 1;
		}
	}
}
int main() {
	return 0;
}
```

###### 先序线索化

1.执行到A，先visit,A的左孩子不为空，第一个if不执行

pre此时是为空，第二个if不执行，

pre指向A结点。

2.执行到B，先visit,B的左孩子不为空，第一个if不执行

pre此时是为A，A的右孩子不为空，第二个if不执行，

pre指向B结点。

2.执行到D，先visit,D的左孩子为空，第一个if执行，把D的左孩子连到B

pre此时是为B，B的右孩子不为空，第二个if不执行，

pre指向D结点。

3.执行到D的左子树，到B。

4.执行B，到D

5.执行执行到D的左子树，到B。

.....

所以要加一个判断，如果D左子树是0的话，没有线索化过，才往左边递归，不然又递归到B了。 

![image-20220524120159261](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524120159261.png)



![image-20220524120516920](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524120516920.png)

结合代码看，爱的魔力转圈圈问题

![image-20220605211234527](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220605211234527.png)

```c++
#include<iostream>
using namespace std;
typedef int ElementType;
typedef struct ThreadNode {
	ElementType data;
	ThreadNode* lChild, * rChild;
	int lTag, rTag;//tag ==0---表示指针指向孩子，tag==1,表示指针是线索。
}ThreadNode, * ThreadTree;
ThreadNode* p;
ThreadNode* pre = NULL;
ThreadNode* finalNode = NULL;
void createPreThreadNode(ThreadTree tree) {
	pre = NULL;
	if (tree != NULL)
	{
		preThread(tree);
		if (pre->rChild == NULL)
		{
			pre->rTag = 1;
		}
	}
}

void visit(ThreadNode* q) {
	//q是当前结点
	if (q->lChild==NULL)
	{
		q->lChild = pre;
		q->lTag = 1;
	}
	if (pre!=NULL&&pre->rChild==NULL)
	{
		pre->rChild = q;
		pre->rTag = 1;
	}
	pre = q;
}

void preThread(ThreadTree tree) {
	if (tree != NULL)
	{
		visit(tree);
		//如果没有线索化过前驱，才需要这样，为什么呢？
		//如果此时Visit过了第三个结点，但是Visit第三个结点之后，还要visit他的左子树呢
		//但是此时左子树的链域已经指向前驱了，意味着什么呢？
		//意味着createPreThreadNode(tree->lChild);的tree->lChild又会变成第二个结点
		if (tree->lTag == 0) 	preThread(tree->lChild);
		preThread(tree->rChild);
	}
}
```



###### 后序线索化

后序线索化，不会出现转圈问题，因为左右孩子都处理玩了

![image-20220524122352089](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524122352089.png)

###### 总结

![image-20220524122455571](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524122455571.png)

![image-20220524122530554](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220524122530554.png)

#### ``线索二叉树前驱后继``

##### 中序后继及正序遍历

> 大致理解

中序是左根右。如果p指向根部的话，那么p的后继就是p的最左下角的一个叶子结点。

如果p->rtag==1,说明线索化过了，那就直接找p->rChild。

如果p->rtag=0,说明没有线索化过，说明P肯定有右孩子（右子树），

按照中序遍历的规则，访问P结点之后，需要中序遍历右子树，右子树第一个被遍历到的结点，就应该是P的后继。

![image-20220525121345443](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220525121345443.png)

> 代码理解

首先：传入的结点肯定是当作根节点看的。访问完根节点之后，肯定访问P的右边，看着王道的顺序先写的FirstNode方法，不用被迷惑，其实先执行的是NextNode方法：

==NextNode :==如果p->rtag==0的话，说明右边没有被线索化过,那就应该找到右子树中第一个被中序遍历的结点。

怎么找？给FirstNode方法传一个右节点的值即可，让FirstNode方法去找右子树的第一个被访问的结点即可。

如果p->rtag==1,说明被线索化过了，那就直接返回右结点。

==Firstnode:==  如果p->ltag==0的话，说明左边没有被线索化过，可以一直找左边的孩子。找谁的最左边的孩子？找的是NextNode传入的根节点的右子树，找到是该右子树的最左边的孩子；

按照中序遍历的规则，右子树最左的孩子肯定是访问了根节点之后，第一个被访问的结点。 

![image-20220525122049346](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220525122049346.png)

```c++
#include<iostream>
using namespace std;
typedef int ElementType;
typedef struct ThreadNode {
	ElementType data;
	ThreadNode* lChild, * rChild;
	int lTag, rTag;//tag ==0---表示指针指向孩子，tag==1,表示指针是线索。
}ThreadNode, * ThreadTree;
ThreadNode* p;
ThreadNode* pre = NULL;
ThreadNode* finalNode = NULL;

ThreadNode* firstNode(ThreadNode *p) {
	//因为是中序，所以先找最左
	while (p->lTag == 0) p = p->lChild;
}
ThreadNode* nextNode(ThreadNode* p) {
	//如果右边，也就是后继，没有被线索化过，那就传入一个结点的右子树
	//让firstNode去找右子树第一个被访问的结点
	if (p->rTag == 0) return firstNode(p->rChild);
	else return p->rChild;
}
```



> 遍历理解

![image-20220531185220695](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531185220695.png)

1.==执行for循环第1句==：传入根节点T，首先去找最左的结点，通过Firstnode函数，找到最左下角的结点，

Firstnode函数中，p->ltag==0时候说明有左子树，

当p->ltag不等于0的时候，说明到底了，没有左子树了，说明是左子树最底下的结点，visit该结点。

2.==执行for循环第2句==，D！=NULL

``D被Visit`

3.==执行for循环的第3句==，p=NextNode(p),NextNode把D->rChild传给FirstNode,也就是G结点传给FirstNode,

FirstNode发现G没有左子树，就直接返回G。

4.==执行for循环第2句，==G!=NULL,然后访问G。

``G被Visit``

5.==执行for循环第3句==，传入G,给NextNode函数，NextNode函数发现G的rLtag不为0，不调用FirstNode,直接返回G的rChild，也就是B。

6.==执行for循环的第2句==，B！=NULL

``B被visit``

7.==执行for循环第3句==，传入B，给NextNode函数，NextNode函数发现B的rltag为0，

就去求助FirstNode，传入E给FirstNode，结果发现E没有左子树，就直接返回给p

8.==执行for循环第2句==，E!=NULL

``E被visit``

![image-20220525122224087](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220525122224087.png)

接下来的过程省略了，总的来说就是，

NextNode就是将一个没有被线索化的结点的右子树，比如B结点的rtag就是0，说明没有被线索化，就把B的右子树E，传给FirstNode

FirstNode就是通过一个while循环，去找某个结点的最下方的左子树。如果结点没有左子树，就直接返回该结点。

![image-20220606114052873](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606114052873.png)

```c++
#include<iostream>
using namespace std;
typedef int ElementType;
typedef struct ThreadNode {
	ElementType data;
	ThreadNode* lChild, * rChild;
	int lTag, rTag;//tag ==0---表示指针指向孩子，tag==1,表示指针是线索。
}ThreadNode, * ThreadTree;
ThreadNode* p;
ThreadNode* pre = NULL;
ThreadNode* finalNode = NULL;

ThreadNode* firstNode(ThreadNode *p) {
	//因为是中序，所以先找最左
	while (p->lTag == 0) p = p->lChild;
}
ThreadNode* nextNode(ThreadNode* p) {
	//如果右边，也就是后继，没有被线索化过，那就传入一个结点的右子树
	//让firstNode去找右子树第一个被访问的结点
	if (p->rTag == 0) return firstNode(p->rChild);
	else return p->rChild;
}
void visit(ThreadNode* p) {
	cout << p->data<<"  ";
}
void inOrder(ThreadNode* T) {
	//首先找到最左边的，然后找到左边的右子树的最左边的，看上图，后继肯定是最左的一个结点
	for (ThreadNode *p = firstNode(T); p!=NULL; p=nextNode(p))
	{
		visit(p);
	}
}
```



##### 中序前驱及逆序遍历

> 大致理解

中序遍历的顺序是左根右，传入一个结点肯定是把这个结点当作根结点，

要找到该节点的前驱，那就是去找左子树，左子树按照中序遍历最后一个被访问的结点，是不是很有道理？

如果左子树只有一个结点，那显然那这个唯一的结点就是根节点的前驱。看图片的黄色的字和红色的字。那必然这个左是根的前驱。

如果左子树有左右孩子，那必然左子树的右孩子是根的前驱。

所以当务之急，是递归找到左孩子的右子树的最右边的结点。

![image-20220528154847808](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220528154847808.png)

> 代码思路

LastNode:循环找到最右的结点。

PreNode:把根结点的左子树传给LastNode,肯定是左子树的最后一个结点遍历完了才遍历根的，所以就传入左子树。



![image-20220528154959136](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220528154959136.png)

RevInorder的思路：传入结点A

找到LastNode,也就是右子树，发现C的没有右子树了，就让p=C了，p!=NULL,此时访问p

然后p=PreNode(p),PreNode函数会把C的左孩子传给LastNode,也就是F结点传过去，LastNode发现F没有右子树，直接返回。F!=NULL,访问F。



![image-20220531201254719](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531201254719.png)

![image-20220606121150400](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606121150400.png)

```c++

ThreadNode* lastNode(ThreadNode* p) {
	while (p->rTag==0)  p = p->rChild;
	return p;
}

ThreadNode* preNode(ThreadNode* p) {
	if (p->lTag == 0) return lastNode(p->lChild);
	else return  p->lChild;
}
//首先用lastNode方法找右子树的结点，首先找到C，然后visit(c),再去找C的前驱。
//前驱怎么找？如果没有被线索化，那么前驱肯定是c的左子树的最右边的一个。如果已经被线索化了，那么前驱就是左指针
void revInOrder(ThreadNode* T) {
	for (ThreadNode *p = lastNode(T); p!=NULL; p=preNode(p))
	{
		visit(p);
	}
}
```



##### 先序后继

如果有根结点P有左孩子的话，那么根的先序后继就是他的左孩子

![image-20220531212016831](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531212016831.png)

如果根节点P没有左孩子那么先序后继就是右孩子

![image-20220531212334217](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531212334217.png)

##### 先序前驱

先序遍历的话，左右子树结点只可能是根的后继，因为是根左右嘛，所以不可能能找到先序前驱，除非用三叉链表，或者用土办法。

三叉链表，给每个结点都设置一个指向父结点的指针。

![image-20220531212946751](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531212946751.png)

来看看如果能找到父节点的情况：

第一种情况，能找到父节点，而且p是父节点的左孩子。

第三种情况，从左兄弟的根结点出发，优先往右走，如果右边的路没有了，我们应该往左边的路走，找到最下面的一个结点，左兄弟的最下面一个结点就是p的前驱。

![image-20220531213307016](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531213307016.png)

![image-20220531213549278](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531213549278.png)

##### 后序前驱

![image-20220531213707021](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531213707021.png)

##### 后序后继

![image-20220531213744698](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531213744698.png)

只能用土办法从头开始先序遍历

或者三叉链表，找到P结点的父节点

第三种情况，如果p是左孩子的话，找到p的后序后继，那就是p的右兄弟的右子树中第一个被访问的结点。

![image-20220531214034735](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531214034735.png)

![image-20220531214304863](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531214304863.png)

##### 总结

![image-20220531214319426](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531214319426.png)

![image-20220531214401656](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531214401656.png)

#### ``树的存储结构``

之前探讨的是二叉树这种特殊的树，现在来探讨普通的树应该设置什么数据结构来存储他。

##### 树的逻辑结构回顾

![image-20220531214839574](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531214839574.png)

##### 双亲表示法

例如C，C的父节点是A，A存储在下标为0的位置，所以C的parent的地方设置为0.

H的双亲是D，所以H的parent域设置成3.

![image-20220531215139256](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220531215139256.png)

这种数据结构如何进行增删改查？

假设此时增加一个M，是H的孩子，此时应该怎么做？在数组中增加一条记录，并且记录parent域H的下标。



![image-20220606212622831](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606212622831.png)

再增加一个L：新增数据的时候，无需按照逻辑上的次序去存储。只需要按照数组的物理位置去存储就可以了。

![image-20220606212945907](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606212945907.png)

如果要删除G元素，有两种方案，第一种方案，把G这个结点的双亲指针设置为-1

第二种方案，把尾部的最后一个数据L移动上来，再把结点数-1

![image-20220606213038443](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606213038443.png)

如果删除的不是叶子结点，如果删除的是根节点的话，如何操作？

假设我们删除D，我们就要==从头开始遍历数组==的parent域，看看几个结点的parent域的值是D的下标

如果我们删除用第一种方式的话，就会多判断一次无效的结点

![image-20220606215241704](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606215241704.png)

![image-20220606215350652](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220606215350652.png)

##### 孩子表示法

![image-20220703203229870](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703203229870.png)

##### 孩子兄弟表示法

最重要的一种方法

![image-20220703203452225](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703203452225.png)

##### 树和二叉树转化

![image-20220703203622334](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703203622334.png)

##### 森林,二叉树转换

![image-20220703203724264](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703203724264.png)

![image-20220703203948953](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703203948953.png)

#### ``树和森林的遍历``

##### 树的遍历

###### 树的先根遍历

先根遍历是优先往深处走，是深度优先遍历

![image-20220703204258384](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703204258384.png)

###### 树的后根遍历

后根遍历是优先往深处走，是深度优先遍历

![image-20220703204339265](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703204339265.png)

###### 层次遍历

层次遍历是广度优先遍历

![image-20220703204454849](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703204454849.png)

##### 森林的遍历

###### 先序遍历

·对每个子树进行先序遍历

![image-20220703204756315](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703204756315.png)

先转换成与之对应的二叉树

![image-20220703205000211](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703205000211.png)

###### 中序遍历

![image-20220703205033084](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703205033084.png)

![image-20220703205045855](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220703205045855.png)

#### 哈夫曼树

``结点的权``：有某种现实含义的数值（如表示结点的重要性）

``结点的带权路径长度``：从树的根结点到该结点的路径长度（经过的边数）与该结点上的权值的乘积

![img](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/JFTIV52LMK4%7DSF8%7BCV%24KHEH.png)

``树的带权路径长度`` :书中所有叶子结点的带权路径长度之和

![image-20220514203818363](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514203818363.png)

来看几个例子：

![image-20220514204220479](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514204220479.png)

``哈夫曼树：最优二叉树``：在含有n个带权叶节点的二叉树中，其中带权路径长度WPL最小的二叉树称为哈夫曼树，也称最优二叉树。

![image-20220514204343984](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514204343984.png)

##### 如何构造？

规则：

``从根节点中选择权值最小的，比如图中的ac``

``权值之和作为根节点的权值``

``再从根节点中选择权值最小的组合``

![image-20220514204812349](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514204812349.png)

哈夫曼树的特征：

``权值越小的结点到根节点的路径长度越大``

``哈夫曼树的结点总数为2n-1``

为什么是2n-1?因为有n个结点，就会结合n-1次，每结合一次，都会出来一个新节点，所以就是n+(n-1)=2n-1

``哈夫曼树不存在度为1的结点``

``哈夫曼树不唯一，但是WPL必然相同且为最优``

不信再构造一遍

![image-20220514205254237](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514205254237.png)

##### 哈夫曼编码

应用1：发电报

![image-20220514205505440](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514205505440.png)

假设老渣和小渣传答案，0代表咳嗽，1代表打喷嚏，假设用ASCII编码传，ASCII编码是8个bit位数，一个选项要咳嗽八次，不优秀。

改变方案：因为只有四个选项，那就用0，1组合成四种状态，每个选项只需要咳两次。

假设有100个题，80题选C，10题选A，8题选B，2题选D，一共要咳嗽200次。

能不能再优化优化？

![image-20220514205641485](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514205641485.png)

来哈夫曼树，只需要咳嗽130次了

![image-20220514210630329](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514210630329.png)

如果把A的10改成1，如果采用这种方式：A变成了非叶子结点

![image-20220514211019058](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514211019058.png)

CAAABD就变成了CBBD

![image-20220514211052777](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514211052777.png)

再来看哈夫曼树：

![image-20220514211133302](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514211133302.png)

所以哈夫曼树都要是叶子结点，而不能是非叶子结点，

换句话说，没有一个编码是另外一个编码的前缀，这样的编码叫做``前缀编码``

C---0,A--1,B--111,D--110,很显然A是1，1是BD的前缀

![image-20220514211354757](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514211354757.png)

![image-20220514211534033](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220514211534033.png)

![image-20220515120020125](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220515120020125.png)



##### 哈夫曼树代码实现

```c++
typedef struct HTNode{
	int weight;//权重
	int parent, lChild, rChild;//父节点，左孩子，右孩子
}HTNode,*HuffmanTree;
```

``m``:是结点总数，要存放在树中的结点总数

``ht``:是实例化了长度为2n的数组，为什么给它多一个空间，让下标和人读的一样，也就是说首节点不放元素

``第一个for循环``:把空间内的所有元素初始化

``第二个for循环``:输入1~n个原始元素的权值

输入原始权值之后，还剩下n-1个元素是之后合并生成的，也就是后面的n+1~m

``第三个for循环``:从n+1~m,先去前面输入的权值中找两个最小的min1,min2所在的位置

两个最小的合并，根节点改成i，也就是n+1个元素

ht[i]的左右孩子就是min1,min2。

然后权重相加

``为什么select函数的参数是i-1?``

我感觉很巧妙，因为每次

```c++
void createHuffmanTree(HuffmanTree &ht,int n) {
	if (n <= 1) return;
	int m = 2 *n - 1;
	ht = new HTNode[m + 1];
	for (int i = 1; i <=m; i++)
	{
		ht[i].lChild = 0; 
		ht[i].rChild = 0; 
		ht[i].parent = 0;
	}
	for (int i =1; i <= n; i++) cin >> ht[i].weight;
	//进行n-1次合并，放在n+1~2n-1
	
	for (int i = n+1; i <=m; i++)
	{
		int min1, min2;
		select(ht,i-1, min1, min2);
		//cout << min1 << " --- " << min2 << endl;
		ht[min1].parent = i; 
		ht[min2].parent = i;
		ht[i].lChild = min1; 
		ht[i].rChild = min2;
		ht[i].weight = ht[min1].weight + ht[min2].weight;
	}
	/*cout << "结点" <<setw(11)<< "权重" << setw(11) << "父结点" << setw(11) << "左孩子" << setw(11) << "右孩子" << endl;;
	for (int i = 1; i <= m; i++)
	{

		cout << i<< setw(11) << ht[i].weight << setw(11) << ht[i].parent << setw(11) << ht[i].lChild << setw(11) << ht[i].rChild << endl;
	}
	cout << "-------------------------------------------------------------" << endl;*/
}
```



##### 哈夫曼编码代码实现

http://www.proedu.com.cn/web/shareVideo/index.action?id=1013461&ajax=1

一个*相当于一个[]

两个*相当于[] [] 

所以就是 char [] []

```c++
typedef char** HuffmanCode;
```

``hc``:是哈夫曼编码数组,也是一个二维数组，肯定只会有n个元素有哈夫曼编码，但是给他n+1个空间。方便阅读

``cd``:是一个一维数组。最后一个元素是结束标志，不放东西。

``f``:指向i的双亲,i从哈夫曼树的第一项开始，也就是你输入的第一项权重开始。

``start``:从cd这个数组的右边往左边开始赋值。

``c``:c是下标，比如第一个元素的下标是1，然后去找当前元素的父节点的左结点有没有等于1的，如果有的话，那编码就是0

如果没有的话，编码就是1.

```c++
void createHuffmanCode(HuffmanTree ht, HuffmanCode &hc,int n) {
	hc = new char* [n + 1];
	char *cd = new char[n];
	cd[n - 1] = '\0';
	int f;
	int start;
	int c;
	for (int i = 1; i <=n; i++)
	{
		start = n - 1;
		c = i;
		f = ht[i].parent;
		while (f!=0)
		{
			--start;
			if (ht[f].lChild == c) {

				cd[start] = '0';
			} 
			else {
				cd[start] = '1';
			}
			c = f; 
            f = ht[f].parent;
		}
		hc[i] = new char[n - start];
		strcpy(hc[i], &cd[start]);
	}
	delete cd;
	
}
```





完整代码实现

```c++
#include<iostream>
#include <string>
#include <string.h>
#include <iomanip>
using namespace std;
typedef struct HTNode{
	int weight;
	int parent, lChild, rChild;
}HTNode,*HuffmanTree;
typedef char** HuffmanCode;
void select(HuffmanTree HT, int m, int& s1, int& s2) {
	int i;
	int min1 = 1000;
	int min2 = 1000;
	for (i = 1; i <= m; i++) {
		if (HT[i].parent == 0 && min1 > HT[i].weight) {
			min1 = HT[i].weight;
			s1 = i;
		}
	}
	for (i = 1; i <= m; i++) {
		if (i !=s1 && HT[i].parent == 0)
			if (HT[i].weight < min2) {
				min2 = HT[i].weight;
				s2 = i;
			}
	}
}
void createHuffmanTree(HuffmanTree &ht,int n) {
	if (n <= 1) return;
	int m = 2 *n - 1;
	ht = new HTNode[m + 1];
	for (int i = 1; i <=m; i++)
	{
		ht[i].lChild = 0; 
		ht[i].rChild = 0; 
		ht[i].parent = 0;
	}
	for (int i =1; i <= n; i++) cin >> ht[i].weight;
	//进行n-1次合并，放在n+1~2n-1
	
	for (int i = n+1; i <=m; i++)
	{
		int min1, min2;
		select(ht,i-1, min1, min2);
		//cout << min1 << " --- " << min2 << endl;
		ht[min1].parent = i; 
		ht[min2].parent = i;
		ht[i].lChild = min1; 
		ht[i].rChild = min2;
		ht[i].weight = ht[min1].weight + ht[min2].weight;
	}
	/*cout << "结点" <<setw(11)<< "权重" << setw(11) << "父结点" << setw(11) << "左孩子" << setw(11) << "右孩子" << endl;;
	for (int i = 1; i <= m; i++)
	{
		
		cout << i<< setw(11) << ht[i].weight << setw(11) << ht[i].parent << setw(11) << ht[i].lChild << setw(11) << ht[i].rChild << endl;
	}
	cout << "-------------------------------------------------------------" << endl;*/
	
}
void createHuffmanCode(HuffmanTree ht, HuffmanCode &hc,int n) {
	hc = new char* [n + 1];
	char *cd = new char[n];
	cd[n - 1] = '\0';
	int f;
	int start;
	int c;
	for (int i = 1; i <=n; i++)
	{
		start = n - 1;
		c = i;
		f = ht[i].parent;
		while (f!=0)
		{
			--start;
			if (ht[f].lChild == c) {

				cd[start] = '0';
			} 
			else {
				cd[start] = '1';
			}
			c = f; f = ht[f].parent;
		}
		hc[i] = new char[n - start];
		strcpy(hc[i], &cd[start]);
		
	}
	delete cd;
	
}

void print(HuffmanTree HT, HuffmanCode HC, int n) {
	for (int i = 1; i <= n; ++i) {
		cout << HC[i] << endl;
	}
}
int main() {
	int n;
	cin >> n;
	HuffmanTree tree;
	HuffmanCode code;
	createHuffmanTree(tree,n);
	createHuffmanCode(tree,code,n);
	print(tree,code,n);
}
```

![img](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/406%7B894_V4CFINF5HX%7B%24Y16.jpg)

### 并查集

![image-20220517212013112](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220517212013112.png)

#### 并查集的优化

### 二叉排序树

#### 定义

![image-20220704184247406](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704184247406.png)

#### 查找

![image-20220704185045834](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704185045834.png)

![image-20220704185352131](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704185352131.png)

#### 插入

![image-20220704195142383](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195142383.png)

![image-20220704195130750](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195130750.png)

```c++
bool bstInsert(BSTree &tree,int data){
	//如果找到一个结点的左右都已经是空了，比如途中的11，要插入的是12，此时传入的是11的右边，
	//所以在右边new了一个结点
	if (tree==NULL)
	{
		tree = new BSTNode;
		tree->key = data;
		tree->lChild = tree->rChild = NULL;
		return true;
	}
	//不允许有两个一样的
	else if (data==tree->key) return false;
	//如果插入值小于结点值，就往左搜索
	else if (data<tree->key) bstInsert(tree->lChild, data);
	else  		bstInsert(tree->rChild, data);
	return true;
}
```

#### 构造

![image-20220704195251059](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195251059.png)

```c++
void createBSTree(BSTree& T, int str[], int n) {
	T = NULL;
	int i = 0;
	while (i<n)
	{
		bstInsert(T, str[i]);
		i++;
	}
}

```

#### 删除

##### 1.删除叶子结点

![image-20220704195450893](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195450893.png)

##### 2.删除的结点只有左子树或者只有右子树

![image-20220704195536724](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195536724.png)

直接替代就行

![image-20220704195559824](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195559824.png)

![image-20220704195626283](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195626283.png)

![image-20220704195634278](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195634278.png)

##### 3.既有左子树,又有右子树

法一:找到最小的结点,直接替换,最小的也就是最左边的,因为是最左边那肯定没有左子树.所以又会变成第二种情况

![image-20220704195756155](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195756155.png)

![image-20220704195859451](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704195859451.png)

法二:找要删除的结点的最右下的结点.

![image-20220704200136899](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704200136899.png)

![image-20220704200144349](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704200144349.png)

#### 效率分析

##### 查找成功

![image-20220704200259789](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704200259789.png)

![image-20220704200316970](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704200316970.png)

##### 查找失败

![image-20220704200447238](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704200447238.png)

![image-20220704200435165](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704200435165.png)

### 平衡二叉树AVL

#### 定义

![image-20220704204634404](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704204634404.png)

插入

![image-20220704204821314](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704204821314.png)

#### 调整

![image-20220704205221714](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704205221714.png)

## 图

### 基本概念

#### 定义

![image-20220704095629194](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704095629194.png)

#### 应用

![image-20220704095702066](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704095702066.png)

![image-20220704095717213](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704095717213.png)

#### 有向图、无向图

有向图用圆括号表示边

无向图用尖括号表示边

![image-20220704095818147](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704095818147.png)

#### 简单图、多重图

![image-20220704095907900](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704095907900.png)

#### 度

![image-20220704095949449](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704095949449.png)

![image-20220704100037145](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704100037145.png)

#### 顶点之间的关系

![image-20220704100236376](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704100236376.png)

#### 连通图、强连通图

![image-20220704100416742](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704100416742.png)

#### 子图

![image-20220704100456711](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704100456711.png)

#### 连通分量---无向图

![image-20220704100536330](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704100536330.png)

长三角能叫连通分量吗？

答：不能，因为尽可能包含更多的边和结点，长三角是和中国铁路网都联通的，所以不能叫做一个连通分量。

但是海南和台湾是能叫做连通分量的。

![image-20220704100720033](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704100720033.png)

#### 强连通分量---有向图

F和ABCDE没有强连通

![image-20220704101021814](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101021814.png)

#### 生成树、森林

![image-20220704101105752](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101105752.png)

![image-20220704101204623](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101204623.png)

#### 边的权，带权图

![image-20220704101256680](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101256680.png)

#### 特殊的图

![image-20220704101404226](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101404226.png)

![image-20220704101420625](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101420625.png)

![image-20220704101455757](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101455757.png)

#### 总结

![image-20220704101519665](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704101519665.png)

### 图的存储

#### 邻接矩阵

##### 不带权图

0表示两个顶点没有边，1表示两个顶点有边。

如何求出度，入度？

看非零元素的个数，

无向图的话，看度的时候看行和列都可以。

`有向图的话，出度看行，入度看列。`

![image-20220629212617878](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629212617878.png)

数据结构可以这样定义

![image-20220629212853760](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629212853760.png)

##### 带权图

如果是带权图：

有的题目把自己指向自己写的是0，有的题目把自己指向自己写的是无穷。这个要稍微注意。

![image-20220629213259623](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629213259623.png)

性能分析：

n个顶点，n^2条边。如果顶点多，边少的话，就很浪费空间。所以适合稠密图（边多的图）

![image-20220629213458213](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629213458213.png)

临接矩阵是对称的，可以压缩

![image-20220629213630344](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629213630344.png)

##### 临接矩阵的性质

意义是什么呢？从A到D这个结点，就只能找到一条符合的路线。

![image-20220629214402703](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629214402703.png)

![image-20220629214435018](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629214435018.png)

总之矩阵的含义就是在矩阵当中对应两个结点之间，长度为2的路径有多少条？

![image-20220629214603159](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629214603159.png)

![image-20220629214922091](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220629214922091.png)

#### 邻接表

![image-20220704162630501](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704162630501.png)

![image-20220704162706824](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704162706824.png)

![image-20220704162751489](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704162751489.png)

#### 十字链表

对于A顺着绿色的(tlink),就能找到从A出发的所有的所有结点的信息。

对于A顺着橙色的(hlink),就能找到指向A的所有结点的信息.

![image-20220704163356208](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704163356208.png)

![image-20220704163904408](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704163904408.png)

#### 邻接多重表

![image-20220704164241504](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704164241504.png)

![image-20220704164556127](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704164556127.png)

![image-20220704164617391](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704164617391.png)

### 图的基本操作

![image-20220704164822818](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704164822818.png)

#### adjacent

![image-20220704165259666](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704165259666.png)

![image-20220704164952456](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704164952456.png)

#### neighbors

![image-20220704165200362](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704165200362.png)

![image-20220704165356131](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704165356131.png)

#### insertVertex

![image-20220704165525006](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704165525006.png)

#### deleteVertex

![image-20220704165645340](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704165645340.png)

![image-20220704165809394](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704165809394.png)

#### addEdge

两个都是O(1)

![image-20220704170019036](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170019036.png)

#### ``firstNeighbor``

![image-20220704170106877](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170106877.png)

![image-20220704170143102](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170143102.png)

#### ``nextNeighbor``

![image-20220704170318231](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170318231.png)

#### 设置获取权值

![image-20220704170504685](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170504685.png)

![image-20220704170515828](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170515828.png)

### 图的遍历

![image-20220704170554660](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170554660.png)

#### 广度优先BFS

![image-20220704170758123](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220704170758123.png)



### 图的应用

#### 最小生成树树

## 查找

### 顺序查找

顺序表和链表都适用。

![image-20220430153345098](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430153345098.png)

哨兵的实现方式：在0号位置放一个待查找的元素。

![image-20220430154324584](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430154324584.png)

![image-20220430154413717](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430154413717.png)

#### 效率分析

``查找成功``



按照王道书的代码来看，从最后一项开始查找，如果第一次就查找到，ASL=1。发生这样的概率大小是1/n。

如果第一次就查找到，ASL=1。发生这样的概率大小是1/n。

如果第二次就查找到，ASL=2。发生这样的概率大小是1/n。

如果第三次就查找到，ASL=3。发生这样的概率大小是1/n。

如果第四次就查找到，ASL=4。发生这样的概率大小是1/n。

....

如果第 i 次就查找到，ASL=n。发生这样的概率大小是1/n。

所以查找成功的平均ASL=(1+2+..n)/n。

![image-20220430155258117](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430155258117.png)

``查找失败``

把每个元素对比一遍，对比n+1次。

![image-20220430155404496](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430155404496.png)

#### 优化1---有序表

![image-20220430162434180](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430162434180.png)

为什么加了两个n？因为对比到失败的时候，有两种情况，一种是37~43，一种是43~无穷大。最底下都要对比N次。

![image-20220430162514411](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430162514411.png)



#### 优化2---被查概率不等

![image-20220430162839722](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430162839722.png)

![image-20220430162908761](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430162908761.png)

###  折半查找

![image-20220430171409436](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430171409436.png)



#### 效率分析

对于这样的序列：

![image-20220426110709083](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426110709083.png)

low和high分别指向头和尾，第一个比较的位置是5这个位置。

![image-20220428194157743](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428194157743.png)

![image-20220428194256583](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428194256583.png)

![image-20220428194341570](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428194341570.png)

> 分析ASL(平均查找长度)：
>
> 1.最上面的一个元素，只需要对比一次元素就能查找到的。
>
> <font color='cornflowerblue'>所以长度是1*1</font>
>
> 2.第二层的两个元素，比如要找到 13，需要对比29 和 13。为什么不对比37呢？因为折半查找的时候，看看第三个图，13刚刚好就是mid,每个结点其实都是Mid.所以每次要找到什么数据，基本上就和层数相关，只要有这个数据，就肯定是arr[mid]=target;
>
> <font color='cornflowerblue'>所以长度是2*2。</font>
>
> 3.第三层的四个元素，比如要查找7，比较了三次，比较29失败了，比较13失败了，比较到arr[mid]=7的时候成功了。又因为第三层有四个元素。
>
> <font color='cornflowerblue'>所以长度是3次乘以四个元素。</font>
>
> 4.第四层是4*4了

![image-20220428200125157](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428200125157.png)

再看失败的情况：

![image-20220428200249028](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428200249028.png)

> 失败的一共有12个元素，第4层是3*4，第5层是4乘以8。
>
> 为什么成功的就是第几层乘以几，但是失败是第几层乘以（层-1）
>
> 假设查的15，比较第一次和29比，15<29。到达13。
>
> 比较第二次和13比，大于13，
>
> 比较第三次和16比，小于16，无需比较了。但是此时在第四层。

#### 折半查找判定树的构造

如果有奇数个元素，挖出来arr[mid]，刚刚好左右相等

![image-20220428200507825](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428200507825.png)

如果有偶数个元素。左边会比右边少一个元素。

![image-20220428201142443](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428201142443.png)

![image-20220428201317812](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428201317812.png)

![image-20220428201346662](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428201346662.png)



这是经典的错误，标准的零分，为什么呢？<font color='red'>在暂时不考虑失败结点的情况下</font>：因为左子树只有0，右子树有2，并不是说单单看一层，第二层的右子树比第二层的左子树多一个，而是看整体的。

![image-20220428201500658](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428201500658.png)

判定树的构造是这样的，图中的序号不是值，而是编号。每次都是右边的优先。

第一层进入第二层的时候，第二层的右边优先。

第二层进入第三层的时候，第三层的右边优先。

![image-20220428202818004](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428202818004.png)

![image-20220428203351013](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428203351013.png)

> 失败结点个数：n+1

![image-20220428203626436](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428203626436.png)

#### 思考

> 思考1，顺序查找一定比折半查找更慢吗？

错，如果顺序查找第一个元素就找到了呢？

![image-20220428203914165](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428203914165.png)

> 思考2，如果构造mid的时候，不是向下取整，而是向上取整呢？

如果是奇数个元素：如果是0~10 有11个元素的话。

mid=(0+10)/2,也就是第五个，左边右边还是一样的

![image-20220428204050152](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428204050152.png)

如果是偶数个元素：如果是0~9 有10个元素的话。

mid=(0+9)/2=5个，那么左边就比右边多了。和之前的完全相反

​	![image-20220428204205857](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428204205857.png)

每一层的第一个元素，就是左边的优先了。

![image-20220428204302615](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220428204302615.png)

### 分块查找

#### 索引顺序查找

建立一个索引表，索引表中保存每个分块的最大关键字和分块的存储区间。

比如7 和 10 在数组内是``0~1``。7和10之间的最大元素是``10``。就保存``10 ``和 ``0，1``

![image-20220430163131703](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430163131703.png)

> 看一个查找成功的例子：
>
> 如果此时查找的是22.首先看maxValue有没有大于22的。很明显有30。然后再从arr[low]找到arr[high]。

![image-20220430163557506](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430163557506.png)

再看一个失败的例子：假设要找的是29.

![image-20220430163826529](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430163826529.png)

#### 折半查找查索引

查找成功

![image-20220430164347885](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430164347885.png)

查找失败：

例如查19的时候，19在表项中。

第一次mid=(low+high)/2,找到mid在30这个位置。

发现arr[mid]>target的话。high=mid-1。

![image-20220430164513428](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430164513428.png)

此时mid=(0+1)/2=0

![image-20220430164647728](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430164647728.png)

此时arr[low]<target,low=mid+1。

![image-20220430164728593](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430164728593.png)

此时arr[low]>target,high=mid-1。

![image-20220430164836049](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430164836049.png)

low>high了，查找失败，但是元素 确实有。

![image-20220430164920810](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430164920810.png)

![image-20220430165010111](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430165010111.png)

![image-20220430165132686](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430165132686.png)

再看一个找不到的例子：

![image-20220430165227349](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430165227349.png)

#### 效率分析

##### 顺序查找

查找7的时候，首先对比第一次，确定分块的位置，再在分块当中对比第一个关键字，就对比了两次。

查找10的时候，首先对比第一次，确定分块的位置，再在分块当中对比第一个关键字，再对比一个关键字，就对比了三次。

查找13的时候，首先对比第一次，确定分块的位置，但是因为第一个分块最大的10比关键字13小，所以再对比一次，20>13。

然后再在分块中对比一次关键字找到13.一共对比了三次关键字。

最后相乘相加即可。

![image-20220430165713331](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430165713331.png)

##### 折半查找

如果查找30，刚刚好arr[mid]就是30。找到了分块，接着去分块中找关键字，需要对比三次。加起来是四次。

找27的时候是不是2次呢？不是。因为30的时候能找到分块，27找不到分块，没有arr[mid]是27.

分析起来太复杂，考试不太可能考。

##### 特别的情况（容易考察）

如果分块有规律。假设有b个块，也就是有b个索引。每个块中有s个元素。

ASL=找到某个块（L1）+找到某个元素（LS）。

L1=（1+2+...+b)/b

Ls=(1+2+...+s)/s。

这个结果怎么来的？因为假设表中有N个元素，那么N=SB.

B=N/S.带入进去即可。

![image-20220430170700572](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430170700572.png)

求导就知道：ASL最小是：

![image-20220430170856228](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430170856228.png)

![image-20220430170942489](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430170942489.png)

### 二叉排序树

### 平衡二叉树

### 红黑树

### B树

### B+树

### 散列查找

#### 散列表（哈希表）

如果不同的关键字通过散列函数映射到同一个值，称为<font color='cornflowerblue'>同义词</font>。

通过散列函数确定的位置已经存放了其他元素，则这种情况称为<font color='cornflowerblue'>冲突</font>。

![image-20220426111125061](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426111125061.png)

如何解决冲突？

以前数组里面是保存一个数据元素的，现在只保存数据元素的指针。

![image-20220426111643385](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426111643385.png)

如果通过这种数据结构进行查找？例如此时查找27：

通过散列函数计算目标的存储地址，27%13=2.....1，也就是1.此时去找数组下标为1的对应的地址。通过链表一个一个往下找。找到了27.

![image-20220426112023816](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426112023816.png)

再比如查找20：

![image-20220426112050543](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426112050543.png)

再看看查找失败的例子：

21%13=1......8.，但是此时8所指的链表是空的。查找长度的次数是0.

![image-20220426112211323](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426112211323.png)

再看看另外一个查找失败的例子：比如查找的是66：

![image-20220426112310895](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426112310895.png)

#### 平均成功查找长度

平均查找长度怎么计算：

对于一行来说：

第一行，也就是如果是通过一次查找就能成功的话，那就是有六个元素，也就是1*6

第二行，也就是如果是通过两次查找才能成功的话，那就是有4个元素，也就是2*4

第三行，也就是如果是通过三次查找才能成功的话，那就是有一个元素，也就是1*3

第四行，也就是如果是通过四次查找才能成功的话，那就是有一个元素，也就是1*4

![image-20220426112403225](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426112403225.png)

也可以通过这种方式来计算：

对于第一列，第一个元素要比较一次，第二个元素要比较两次，第三个元素要比较三次，第四个元素要比较四次

对于第三列，第一个元素要比较一次，第二个元素要比较两次

对于第六列，第一个元素要比较一次，第二个元素要比较两次

对于第七列，第一个元素要比较一次

对于第十列，第一个元素要比较一次，第二个元素要比较两次

对于第十一列，第一个元素要比较一次

综上：（1+2+3+4+1+2+1+2+1+1+2+1）/12

这种方式很明显的能看出，大于1的，肯定是存在了冲突，并且数值越大，冲突程度越高。

![image-20220426114525961](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426114525961.png)

最理想的情况是这样的：如何设计一个哈希函数，让冲突变少呢？我们先看看失败的平均查找长度

![image-20220426115658558](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426115658558.png)

#### 平均失败查找长度

对于第一列，失败的查找长度是0

对于第二列，失败的查找长度是4，因为要对比四次。

...

...

总结规律不难发现，其实ASL失败的``分子``就是``散列表的总记录数``，也就是总元素数。``分母``是``散列表的长度``。

![image-20220426120154374](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426120154374.png)

> 装填因子=表中的记录数/散列表的长度。也就是装的满不满。
>
> 装的越多，发生冲突的可能性越大。

![image-20220426120652114](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426120652114.png)

#### 设计冲突少的散列函数

##### 除留余数法

![image-20220426160301201](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426160301201.png)

![image-20220426160350040](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426160350040.png)

![image-20220426160432454](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426160432454.png)

![image-20220426160609953](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426160609953.png)

##### 直接定址法

比如一个班级的学生，第一个人学号是1120112176，那就设计一个key=1120112176(第一人的学号)，

H(key)=key-1120112176，这样每个同学都被存储在不同的位置。不会产生冲突。这是关键字分布连续的情况。如果分部不均匀，那就会产生很多空位。

![image-20220426160734579](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426160734579.png)

![image-20220426160746347](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426160746347.png)

##### 数字分析法

![image-20220426161330157](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426161330157.png)

##### 平方取中法

这种方法是在一些关键字分部不均匀的时候，比如身份证，湖南省的都是430，衡阳县的都是421，很不均匀，都集中在430421，这时候怎么办呢？就是取平方。比如把 430421199804069359的80406，取平方。

![image-20220426161018010](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426161018010.png)

![image-20220426161235354](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426161235354.png)

![image-20220426161249686](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426161249686.png)

#### 冲突的处理

##### 链地址法---HashMap,HashSet

![image-20220426162203295](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220426162203295.png)

##### 开放定址法

###### 线性探测法

![image-20220429122339166](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429122339166.png)

数组里面还是实实在在的存放数据元素，不会像拉链法一样，存放的是链表。

> 空闲的地址，既对同义词表项开放，也对非同义词开放。什么意思呢？

因为表长是0~16，那么16以内最大的素数就是13.所以除以13取余。假设14，19，23都放好了。下一个放1。

先计算H(key)=1%13=1。

再计算H0=（1+d0）%16=1。

所以把1放在1号位置。

![image-20220429121904274](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429121904274.png)

但是显然1会发生冲突。

此时发生了一次冲突，H1=（1+d1）%16=2,此时没有冲突。d1也就是d0后面一个位置。

![image-20220429122132733](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429122132733.png)

接下来68,20都没有冲突。

H(key)=68%13=5....3,就等于3

H0=（H(key)+d0）%16=(3+0)%16=3;

![image-20220429122635942](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429122635942.png)

接下来是84

H(key)=84%13=6....6,就等于6

H0=（H(key)+d0）%16=(6+0)%16=6;

H1=（H(key)+d1）%16=(6+1)%16=7;

H2=（H(key)+d2）%16=(6+2)%16=8;

![image-20220429123106818](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123106818.png)

最后：

如果要查找27.

![image-20220429123307539](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123307539.png)

![image-20220429123351046](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123351046.png)

查11：

![image-20220429123412538](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123412538.png)

查21：

![image-20220429123429984](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123429984.png)

线性探测为什么空位置判断要算一次比较？但是链地址法就不算一次比较？因为链地址是空指针。但是线性探测是数组的元素，就是和空指针不一样。

从这个例子可以看出来，只要遇到空地址，就算查找失败，所以早点遇到空地址，就能早点知道查找是否失败了。

![image-20220429123526902](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123526902.png)

早点遇到空地址，就能早点知道查找是否失败了。

![image-20220429123826449](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429123826449.png)

> 删除一个元素

假设此时把1删除，要查找27，但是之前说遇到空的，就代表查找不到了。但是此时列表中有27这个元素。

![image-20220429154218874](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429154218874.png)

![image-20220429154514676](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429154514676.png)

做一个标记，保证它能继续往后

![image-20220429154648059](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429154648059.png)

假设前面的都被逻辑删除了...

![image-20220429154707357](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429154707357.png)

![image-20220429155030257](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429155030257.png)

> 查找效率

``查找成功的情况``：

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429165342474.png"/>

本题中：

![image-20220429155143214](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429155143214.png)

``查找失败的情况``：

![image-20220429165342474](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429165342474.png)

为什么分母是13？

因为有可能映射到0这个位置，其实是【0，12】,一共有13中可能性。

本题中。如果在0处查找失败，只需要对比一次就知道是查找失败的。

如果在1处查找失败，需要对比13次。1失败，2失败，3失败....12失败，13为空停止算一次

如果在2处查找失败，需要对比12次。2失败，3失败....12失败，13为空停止算一次

如果在3处查找失败，需要对比11次。3失败....12失败，13为空停止算一次

![image-20220429165331083](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429165331083.png)

> 堆积是什么？就是所有的元素都在一堆

![image-20220430192016416](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220430192016416.png)

![image-20220429165439817](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429165439817.png)

###### 平方探测法

这些元素取模都是6，下面看看19怎么放？19第0次发生冲突不成立，到第一次发生冲突,d1=1。

(H(key)+1)%27=7。19放到7这个地方。

![image-20220429165636068](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429165636068.png)

接下来看32，d2=-1

![image-20220429165958612](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429165958612.png)

![image-20220429170052253](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429170052253.png)

``其实这个增量就是走几步，如果是正数，那就是往右边走几步，如果是负数，那就是往左边走几步``

如果84，是6这个位置，往左边走九个，但是没有九格，就会0左移的时候到26...所以就是24这个位置

![image-20220429170326106](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429170326106.png)

``平方探测法要求散列表的长度一定要是4j+3这样的值，j=0,1,2，不然可能探测不到``

![image-20220429170627011](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429170627011.png)

###### 伪随机序列法

![image-20220429171021567](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429171021567.png)

###### 总结

![image-20220429173649596](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429173649596.png)

![image-20220429174145417](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429174145417.png)

##### 再散列法

除了原始的散列函数，多准备几个散列函数。

![image-20220429173920972](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220429173920972.png)

## 排序

### 基本概念

#### 排序算法的评价指标

![image-20220408085315485](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408085315485.png)

![image-20220408085638014](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408085638014.png)

![image-20220408091345624](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408091345624.png)

### 交换排序

#### 冒泡排序

#### 快速排序

> 我们用low和high两个指针，和pivot这个基准元素进行操作。
>
> 首先写一个partition函数，partition函数是用来划分的。用一个基准元素，划分左右。
>
> partition函数中：让一个pivot枢轴等于low指向的值。一般low和high初次传的都是0 和 数组的长度。
>
> 例如此时的基准元素pivot=arr[low]=arr[0]=49;low和high分别指向49 和 49
>
> 当low<high的时候，
>
> 当arr[high]大于等于基准元素pivot，high指针就往左移。
>
> 如果arr[high]比pivot小，就把arr[high]放到arr[low]的位置。
>
> 当arr[low]小于等于基准元素，low指针右移。
>
> 如果arr[low]比pivot大，就把arr[low]放到arr[high]的位置。
>
> 这样基准元素左边的，就都比基准元素小，基准元素右边的，就都比基准元素大。然后再用递归，对左右分别排序。

对于49 38 65 97 76 13 27 49 这样的序列

![image-20220408092051357](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092051357.png)

![image-20220408092449509](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092449509.png)

![image-20220408092537319](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092537319.png)

![image-20220408092602528](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092602528.png)

![image-20220408092625658](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092625658.png)

![image-20220408092643511](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092643511.png)

![image-20220408092737766](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092737766.png)

![image-20220408092906317](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092906317.png)

![image-20220408092926324](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092926324.png)

![image-20220408092933979](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408092933979.png)

![image-20220408093019873](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220408093019873.png)

​	

### 插入排序

#### 直接插入排序

> 刚开始从第二个元素开始，认为当前处理的元素之前是已经排序好的，需要把当前的元素38，和之前排序好的元素依次对比。
>
> 比当前元素38更大的，都需要依次后移。目前只有49

![image-20220414203216735](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203216735.png)

接下来处理65这个元素，检查当前元素65和排序好的38，49做对比。比当前元素大的都后移。因为38和49都比65小，所以不后移。

![image-20220414203240988](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203240988.png)

97略，接下来处理76这个元素，当前元素和排序好的38 49 65 97 对比，发现97比当前元素76大，将97后移。

![image-20220414203309614](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203309614.png)

现在处理13这个元素，97比13大，97右移，76比13大，右移，.....一直到13变成最前面。

![image-20220414203324167](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203324167.png)

![image-20220414203339343](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203339343.png)

现在处理27这个元素，把38~97的全部右移。

![image-20220414203355269](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203355269.png)



![image-20220414203402711](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203402711.png)

> 如果两个元素相等，就不移动，保证算法的稳定性。

![image-20220414203417164](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220414203417164.png)

##### 代码实现

> 主要思想是：
>
> 例如49 38 65 97 76 13 27 49
>
> 从38开始也就是从下标为1开始，左边的默认是排序好的，目前的左边只有49。现在发现左边的比较大，如果升序排序的话，就要换位置了。
>
> 38 49 65 97 76 13 27 49 ，现在指向65，这时候会比较65和49的大小，为什么不用比较38呢？因为默认已经是有序的了。发现此时还是升序，不交换位置。
>
> 当i=76这个位置的时候，发现i-1项是97这时候需要交换位置，并且要用循环去前面找。
>
> 先用temp保存76，然后和97前面的一项一项比较。如果前面有arr[j]>temp的，就直接依次后移。
>
> j会移动到什么位置？用这个序列来说明：38 49 65  76 97 13 27 49 
>
> 会一直移动到没有大于temp的数字位置。此时的j已经自减到-1，-1已经不满足条件了，所以最后arr[j+1]=temp;

主函数

```c++
int main() {
	int length;
	cin >> length;
	int* arr = (int*)malloc(sizeof(int) * length);
	if (!arr) 	return 0;
	for (int i = 0; i < length; i++)
	{
		cin >> arr[i];
	}
	insertSort(arr, length);
	/*cout << "----------------------------------"<<endl;
	output(arr, length);*/
	return 0;
}
```

输出函数

```c++
void output(int arr[], int length) {
	for (int i = 0; i < length; i++)
	{
		cout << arr[i];
	}
	cout << endl;
}
```

> 核心代码

```c++
void insertSort(int arr[],int length) {
	int i,j,temp;//i用来保存标志变量，一般从数组第二个元素开始。j用来找到i左边的变量，用temp来保存标志变量的值。
	for (i = 1; i < length; i++) {
		if (arr[i] < arr[i - 1])//如果右边的元素比左边的元素更小，比如97，38...就把38给Temp
		{
			temp = arr[i];//用temp保存右边的标志变量的值，准备交换
			for (j = i - 1; j >= 0 && arr[j] > temp; --j)//此处for循环只控制一条语句
				arr[j + 1] = arr[j];//把最大的给i，因为从i=2开始，前面其实都是排序好了的，如果i移动到的元素，比前面排序好的元素的最大一个值小，那就依次把小的前移
			arr[j + 1] = temp;//再把原来的arr[i]里面保存的值，给arr[i-1],因为此时的j是i-2了

			output(arr, length);
		}
	}
		
}
```

##### 算法效率分析

如果是带哨兵的方式，如果数组长度length为n，因为第一个是哨兵，所以只需要循环n-1次。时间复杂度主要来源于每一次对比前一个元素和后一个元素，以及每次移动元素。

最好的情况就是本来就有序，每次只对比元素，时间复杂度就是O(N)的数量级；

最坏的情况是逆序的，你想要升序，它就逆序，你想要逆序，他就是升序。

![image-20220424210512758](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220424210512758.png)

比如现在处理到最后一趟排序的时候：前面的都基本有序了，现在处理到10.用10依次往左边对比，并且后移。

![image-20220424210700569](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220424210700569.png)

![image-20220424210953004](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220424210953004.png)

##### 优化---折半插入排序

看见low,mid,high和i大概是什么意思：

假设此时i指向55这个元素：

![image-20220424215125771](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220424215125771.png)

此时的mid是比arr[0]这个哨兵小的，所以要插入在mid右边的元素。让low移动过去，也就是low=mid+1;也就是70这个位置。

移动完了之后。继续求mid,mid此时在70这个位置，arr[mid]还是大于arr[0]。

![image-20220424215343598](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220424215343755.png)

因此会在70左边的区间内，找个地方插入元素，所以high要左移到mid-1,也就是和low一个位置，low还是<=high的，所以还会求一次mid,mid=(low+high)/2,也就是（5+5）/2，还是5。此时三个指针在一个位置，都在60上。

![image-20220425190353779](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220425190353779.png)

此时arr[mid]还是比哨兵元素大，继续让high=mid-1,也就是50这个位置。

j=i-1;arr[j + 1] = arr[j];//这是右移的代码，如何理解？

j=80这个位置，j+1就是55这个位置，把55的值覆盖掉。把前面一个值，赋值到后面。其实可以想象成右移的过程。

最后空出来的位置，也就是low这个位置，用哨兵给它赋值上。

![image-20220425190509200](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220425190509200.png)

![image-20220425190531090](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220425190531090.png)

下一个元素是60，

```c++
void insertSort(int arr[],int length) {
	int i, j, low, high, mid;
	for ( i = 2; i <=length; i++)//从第三个元素开始，第一个元素arr[0]用作哨兵，我们写插入排序都是从第一个元素之后插入的，所以是arr[2]开始
	{
		if (arr[i]<arr[i-1])//如果右边的比左边的要小
		{
			arr[0] = arr[i];
			low = 1; high = i - 1;//low从第一个开始，high从i的左边一个开始，因为i比左边的小
			while (low<=high)
			{
				mid = (low + high) / 2;//中间元素取mid
				if (arr[mid]>arr[0])//如果中间元素大于哨兵，也就是arr[i]
				{
					high = mid - 1;
				}
				else {
					low = mid + 1;
				}
			}
			for ( j = i-1; j>=high+1; --j)
			{
				//arr[j] = arr[j-1];//不能这样写，虽然表达的意思差不多，都是把元素后移，把第j-1个元素移动到第j个元素上,但是j-1可能会到哨兵上去
				arr[j + 1] = arr[j];
			}
			arr[high+1] = arr[0];
		}

	}
}
```



#### 希尔排序

希尔本人建议：每次将增量缩小一半，直到缩小为1为止。

![image-20220415114649924](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/image-20220415114649924.png)

![image-20220415153228948](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153228948.png)

![image-20220415153051029](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153051029.png)

![image-20220415153129468](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153129468.png)

第一趟处理完成之后：

![image-20220415153205639](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153205639.png)

第二趟：

![image-20220415153319213](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153319213.png)

![image-20220415153347258](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153347258.png)

![image-20220415153357515](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153357515.png)

![image-20220415153407993](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153407993.png)

第三趟：整个表已经基本有序

![image-20220415153428595](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153428595.png)

![image-20220415153535673](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415153535673.png)

> 定义一个d作为增量，d等于数组长度/2,每次都/2
>
> i=d+1=3;arr[3]也就是2，i-d也就是arr[1];

```c++
void shellSort(int arr[], int length) {
    //比如5 4 3 2 1 ，此时length是5
	int d, i, j;
	for (d=length/2; d>=1; d/=2)//d=5/2,d=2;
	{
		for (i = d + 1; i <= length; ++i) {//i=3
			if (arr[i] < arr[i-d])//arr[3]<arr[3-2]
			{
				arr[0] = arr[i];
				for (j=i-d; j > 0&&arr[0]<arr[j]; j-=d)
				{
					arr[j+d]=arr[j];
				}
				arr[j + d] = arr[0];
			}
		}
	}
}
```

### 选择排序

#### 简单选择排序

![image-20220415185735234](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415185735234.png)

> 如何理解arr.length-1?
>
> 遍历整个数组，找到最小的元素，将最小的元素和arr[进行到哪一趟]的元素进行换位。一共需要进行arr.length-1趟。因为最后一个元素是默认排序好了的。
>
> 如何理解第二层排序是int j=i+1;j<length?
>
> 因为每次进入内层排序的时候，都是从i后面开始找比arr[i]小的元素的。所以是j=i+1
>
> 为什么j<length?因为j需要遍历i之后的元素，才能找到最大的元素或者最小的元素

![image-20220419092704062](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220419092704062.png)

```java	
void selectSort(int arr[], int length) {
	for (int i = 0; i < length-1; i++)
	{
		int min = i;
		for (int j = i+1; j < length; j++)
		{
			if (arr[j] < arr[min]) {
				min = j;
			}
		}
		if (min!=i)
		{
			arr[i] = arr[i] ^ arr[min];
			arr[min] = arr[i] ^ arr[min];
			arr[i] = arr[i] ^ arr[min];
		}
		outPutArr(arr, length);

	}
}
```



#### 堆排序

大根堆和小根堆

![image-20220422200106945](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422200106945.png)

其实堆就i是顺序存储的完全二叉树。

大根堆是什么意思呢？下标为i的结点的左孩子是2i,右孩子的下标是2i+1.i的值小于等于n/2的时候

![image-20220422202214233](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422202214233.png)

小根堆：

![image-20220422203334340](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422203334340.png)

因为选择排序的就是选择一个最大的或者最小的。所以如果能够根据大根堆和小根堆的特性，很方便能选出来。

现在来建立大根堆：

先找父节点，i<=n/2，也就是前面四个，第四个就是最小的父节点。根据二叉树的特性，找到左孩子和右孩子。

![image-20220422204547889](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422204547889.png)

不满足结点大于孩子，就互换：

![image-20220422204623153](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422204623153.png)

再处理三号结点：

![image-20220422204639801](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422204639801.png)

![image-20220422204659337](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422204659337.png)

再处理二号结点：

17比左右孩子都小，和最大的孩子互换

![image-20220422204850552](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422204850552.png)

![image-20220422204921613](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422204921613.png)

最后处理一号结点：

![image-20220422205000350](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422205000350.png)

现在元素下坠。。。53没有比孩子结点大。

![image-20220422205019056](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422205019056.png)

需要再调整，现在的结果就初步满足大根堆。

![image-20220422205112756](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422205112756.png)

> 代码实现：

本来是从9开始的，但是现在就不一步一步分析了，直接从最顶上的53开始

![image-20220423193040569](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423193040569.png)

从这里开始：此时arr[k]传的是53了。

![image-20220423192356149](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423192356149.png)

```c++
void headAdjust(int arr[],int k,int length) {//k就是根
	arr[0] = arr[k];//k是根结点
	for (int i = 2*k; i <=length; i*=2)//i其实指向的是左孩子
	{
		if (i < length && arr[i] < arr[i + 1]) {//只要i<length才能保证，i是有右兄弟的，如果左孩子比右孩子小，那就取右孩子的下标
			i++;
		}
		if (arr[0]>=arr[i])//如果此时的根节点比孩子最大的大，那么就直接break掉，啥也不用干。
		{
			break;
		}
		else {
			arr[k] = arr[i];//把i所指的孩子结点，换到此时处理的根节点。
			k = i;//再把i的值赋值给k,
		}
	}
}
```

如何理解else里面的代码？因为此时的根节点比孩子结点小，所以把孩子节点的值赋给原来的根节点。再让k移动到孩子结点的位置，下次再*2.

也就是此时根节点是45 和 87 的父节点 53，比右孩子小，不满足if（A[0]>=A[i]）,进入到else里面，此时把A[k]赋值给A[i]，也就是说把原本的父节点53变成87。但是此时A[0]保存的根节点53，要不要赋值给原来的右孩子A[k]呢？也就是此图的87的位置，53能不能坐得稳呢？很显然，坐不稳。因为65 和 78 都比53 大，不满足大根堆。

![image-20220422214327230](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422214327230.png)

还需要进行下一轮循环，才知道要不要把根结点的值，换到孩子结点的位置上来，因为根节点比孩子的结点小，但是现在不知道根结点的值会不会比孩子结点的孩子节点的值小。

所以继续进行下一轮循环。把i的值赋值给她，也就是87的孩子结点的右节点，此时的k等于87的右节点，再次去找，再次乘以2，找到了65，如果左孩子比右孩子小，那就i++,也就是取右孩子。此时就是取最大的78，如果A[0],也就是之前保存的53，比最大的大，那就直接Break掉了。但是很显然不满足，所以不能Break掉。

还是继续执行A[k]=A[i],k是53空白处这个位置，A[i]是78，然后再把i的值给k，再i*2。此时i已经指向78了，再乘以2的话，已经不满足i<=len了，所以这次结束。

![image-20220422214935629](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220422214935629.png)

![image-20220423193559321](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423193559321.png)

建立好了大根堆之后，如何用大根堆进行排序呢？

![image-20220423193712245](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423193712245.png)

 调整好了之后，现在9在最上面，现在再把9下坠，继续调用建立大根堆的方法。

![image-20220423193735998](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423193735998.png)

k=1,len=7

![image-20220423193929342](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423193929342.png)

![image-20220423194012874](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194012874.png)

第二趟：

53不满足大根堆

![image-20220423194048321](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194048321.png)

78现在已经不属于堆了

![image-20220423194124279](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194124279.png)

第三趟：

![image-20220423194219162](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194219162.png)

![image-20220423194230932](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194230932.png)

第四趟：

17和53换位，再把17下坠

![image-20220423194251201](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194251201.png)

17的左孩子的左孩子比17还大，所以是这样：

![image-20220423194328962](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194328962.png)

第五趟：

堆顶和堆底互换：

![image-20220423194416036](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194416036.png)

![image-20220423194531457](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194531457.png)

......

![image-20220423194643235](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423194643235.png)

##### 完整代码实现

![image-20220423202057558](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423202057558.png)

```c++
//建立大根堆，从最底下的父节点开始建立，从下到上建立
void buildMaxHeap(int arr[],int length) {
	for (int i = length/2;  i >0;  i--)
	{
		headAdjust( arr,  i,  length);
	}
}

void headAdjust(int arr[],int k,int length) {//k就是根
	arr[0] = arr[k];//k是根结点
	for (int i = 2*k; i <=length; i*=2)//i其实指向的是左孩子
	{
		if (i < length && arr[i] < arr[i + 1]) {//只要i<length才能保证，i是有右兄弟的，如果左孩子比右孩子小，那就取右孩子的下标
			i++;
		}
		if (arr[0]>=arr[i])//如果此时的根节点比孩子最大的大，那么就直接break掉，啥也不用干。
		{
			break;
		}
		else {
			arr[k] = arr[i];//把i所指的孩子结点，换到此时处理的根节点。
			k = i;
		}
	}

	void heapSort(int arr[],int length) {
		buildMaxHeap(arr,length);
		for (int i = length; i >0; i--)
		{
			swap(arr[i],arr[1]);//因为之前初步建立了大根堆，说明选出来了最大的元素在堆顶，也就是第一个元素，将第一个元素和最后一个元素互换，也就是堆顶和堆底元素互换
			headAdjust(arr,1,i-1);//再建立大根堆，将小元素下坠，从第一个元素开始下坠，每次下坠i-1，因为树下面的元素全都排序好了
		}
	}

	void swap(int nums1,int nums2) {
		nums1 = nums1 ^ nums2;
		nums2 = nums1 ^ nums2;
		nums1 = nums1 ^ nums2;
	}
}
```

![image-20220423202346954](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423202346954.png)

##### 堆的插入和删除

堆的插入：

新元素暂时放到表尾，二叉树的最底下。然后再上升。

堆的删除：

先删掉该元素，然后再让表尾元素顶替她。然后再下坠。

![image-20220423203029332](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220423203029332.png)



### 归并排序

> i所指的元素是12，j所指的元素是7，j更小，把j放到所指的位置，同时j,k后移。

![image-20220415191023266](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415191023266.png)

![image-20220415191132411](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415191132411.png)

> 如果i,j指到的都一样，可以让i优先，也可以j优先

![image-20220415191220687](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415191220687.png)





#### 四路归并

m路归并，要对比m-1次

![image-20220415191345317](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415191345317.png)

<img src="https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220415191511832.png"/>

#### 代码实现

我们要合并low~mid,和mid+1~high.

我们用一个k,把A中的元素复制到B

> 递归怎么理解？第一轮high=5,为什么是5不是6，因为数组是0-5。此时mid=（0+5）/2
>
> ​          mid
>
> 49 38 65 97 76 13 
>
> 此时会进入递归函数，也会有一个判断的if(low<high),此时的high是2，满足条件，继续递归。
>
> 

![image-20220418175554153](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418175554153.png)

>  第二轮mid=（0+2）/2=1
>
> ​    mid
>
> 49 38 65 97 76 13 ,满足递归函数内部的low<high

![image-20220418175950615](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418175950615.png)

> 第三轮mid变成了（0+1）/2=0，不满足递归条件，执行下面的语句,就是在比较 49 和 38 之后,merge完了，直接放入数组

![image-20220418180116272](https://raw.githubusercontent.com/xiaomingAndroi/picture-bed/master/typoraTest/image-20220418180116272.png)

### 外部排序

#### 置换选择排序

### 败者树

### 最佳归并树
